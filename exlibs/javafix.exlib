# Copyright 2010 Cecil Curry <leycec@gmail.com>
# Distributed under the terms of the GNU General Public License v2
#
# --------------------( SYNOPSIS                           )--------------------
# This exlib improves "java.exlib" with handling for command-line properties,
# external dependencies, and jar and javadoc installation. These improvements
# should be backported into "java.exlib" where deemed appropriate.
#
# This exlib is thus backwards compatible with other exlibs and exheres
# requiring "java.exlib".
#
# --------------------( ETYMOLOGY                          )--------------------
# Technically, an javafix is "an ornament of the cymatium of a classic cornice,
# sometimes pierced for the escape of water." In reality, I'm not sure I know
# what a cymatium is. Or a cornice.

# ....................{ EXHERES                            }....................
require java
export_exlib_phases pkg_setup \
    src_unpack src_prepare src_configure src_compile src_test src_install

# ....................{ CONFIGURATION                      }....................
# Array of Java JDK prefixes. If the following expression is true for at least
# one ${JAVA_RESTRICT_JDK_PREFIX} of this array, then installation fails
# prior to performing any work:
#     [[ $(eclectic java-jdk show) = "${JAVA_RESTRICT_JDK_PREFIX}"* ]]
#
# Common example for exheres failing under "gcj" or "gij":
#     JAVA_RESTRICT_JDK_PREFIXES=( gcj )
#
# As of mid 2010, all Ant exheres should test compilation under "gcj". Many will
# fail! Those that do should set this array, as above.
JAVA_RESTRICT_JDK_PREFIXES=( )

# Hamcrest does not compile under "gcj", currently.
JAVA_RESTRICT_JDK_PREFIXES=( gcj )

# Find parameters to be passed to the command-line invocation of "find" when
# cleaning jar files from ${WORK}. Specify this to prevent cleaning of wanted,
# specific jar files: e.g.,
#     JAVA_CLEAN_JAR_FILES_PARAMS=( -not -wholename 'bootstrap/young_lad.jar' )
JAVA_CLEAN_JAR_FILES_PARAMS=( )

# Absolute or relative path under "${WORK}" into which external jar files will
# be symlinked. Though this path is typically "lib" for most exheres, you must
# still specify this global to have symlinking performed for you. Example:
#     JAVA_SRC_PREPARE_SYMLINK_DIR="lib"
JAVA_SRC_PREPARE_SYMLINK_DIR=""

# Array of absolute paths to or relative names of external jar files to be
# symlinked into "${JAVA_SRC_SYMLINK_DIR}". These external jar files should
# generally be buildtime dependencies of this exheres. Example mixing both
# absolute paths to and relative names of external jar files:
#     JAVA_SRC_PREPARE_SYMLINK_JARS=( jarjar qdox "/usr/share/asm/asm.jar" )
#
# If filenames are not known until install time, leave this array blank and
# call "symlink_jars" within your "${PN}_src_prepare" function.
JAVA_SRC_PREPARE_SYMLINK_JARS=( )

# Array of absolute paths to text files to be "deversion"-ated. Ant "build.xml"
# files often hardcode references to pre-bundled jar files with names suffixed
# by a version specifier. This is bad, as this exlib replaces all pre-bundled
# jar files with externally symlinked jar files with names NEVER EVER suffixed
# by a version specifier. To resolve the discrepancy, we could do one of two
# ugly hacks:
#
# * Sed affected "build.xml" files, removing jar filename version specifiers OR
# * Grep affected "build.xml" files for these version specifiers and, when
#   symlinking in external jar files, add the version specifier for each jar
#   filename to its symlink filename.
#
# The first is easier. And easier is better. So that's what we do. Example
# deversioning two files, "build.xml" and "common-build.xml":
#     JAVA_SRC_PREPARE_DEVERSION_FILES=( "${JAVA_BUILD_XML}" "common-build.xml" )
JAVA_SRC_PREPARE_DEVERSION_FILES=( )

# Absolute or relative path under "${WORK}" into which javadoc HTML files will
# be generated by the "${JAVA_BUILD_XML}" file for this exheres. Though this path
# is typically "javadoc" for most exheres, you must still specify this global to
# have installation of these files performed for you. Example:
#     JAVA_SRC_INSTALL_JAVADOC_DIR="javadoc"
JAVA_SRC_INSTALL_JAVADOC_DIR=""

# Array of absolute paths to this exheres' output jar files to be installed
# under "${JAVA_SRC_INSTALL_JARS_IMAGE_DIR}". Versions are automatically removed
# from filenames on your behalf. (Yippee...!) Example:
#     JAVA_SRC_PREPARE_INSTALL_JARS=( "dist/${PNV}.jar" )
#
# If filenames are not known until install time, leave this array blank and
# call "install_jars" within your "${PN}_src_install" function.
JAVA_SRC_INSTALL_JARS=( )

# ....................{ CONSTANTS                          }....................
# This exlib sets these constants on your behalf. Read them; don't write them.
# 
# Scratch that -- don't even read them. If you access these constants in any
# exheres, you're doing something wrong. :)

# Set to the currently selected Java compiler as reported by...
JAVA_JDK=$(eclectic java-jdk show)

# Set, if disabling sydbox's network sandboxing. At the moment, this is only
# enabled when "gcj" is the currently selected Java compiler. This additionally
# implies that "gij" is the currently selected Java interpreter.
#
# See the "java_pkg_setup" function for detail.
JAVA_IS_DISABLING_NETWORK_SANDBOXING=

# Set, if installing javadoc. (This is set for you if and only if "doc" is
# enabled for this exheres.)
JAVA_IS_INSTALLING_JAVADOC=

# Set, if recursively deleting all class files from "${WORK}" immediately after
# extracting source tarballs. Such class files are often bundled with tarballs
# to avoid the need for user recompilation. Make them suffer; oh, yes.
#
# Defaults to set.
JAVA_IS_CLEANING_CLASS_FILES=1

# Set, if recursively deleting all jar files from "${WORK}" immediately after
# extracting source tarballs. Such jar files are often bundled with tarballs
# to reduce dependency hell. For us, bundled jar files only aggravate hell.
#
# Defaults to set.
JAVA_IS_CLEANING_JAR_FILES=1

# Absolute path to which this exheres installs output jar files.
#
# Avoid changing this global unless you absolutely must, as that probably breaks
# things elsewhere (e.g., other exheres trying to import these jar files).
#
# This defaults to the empty string; if still the empty string during the
# "pkg_setup" phase, then that phase resets this to a proper default. We wait
# until that phase as the proper default depends on exheres globals (e.g.,
# ${SLOT}) that will only be set after the exheres requires this exlib.
JAVA_SRC_INSTALL_JARS_IMAGE_DIR=

# Bash pattern matching the version suffix commonly appended to jar filenames.
# This pattern matches conventional versions (e.g., "hamcrest-1.2.jar") and
# unconventional revisioned versions (e.g., "jarjar-1.0rc8.jar"). By design,
# this pattern may also be passed without change to "egrep" or "sed -r".
#
# Don't forget to append a '$' if appropriate!
JAVA_JAR_VERSION_PATTERN='-[[:digit:].]+(rc[[:digit:].]+)?\.jar'

# Bash pattern matching the same from within a parameter expansion: e.g.,
#
#    Echoes "harhar.jar".
#    JAR_FILE=harhar-5.62.951.jar && \
#        echo ${JAR_FILE/${JAVA_JAR_PARAMETER_VERSION_PATTERN}/.jar}
JAVA_JAR_PARAMETER_VERSION_PATTERN='%-+([[:digit:].])*(rc+([[:digit:].]))\.jar'

# Sed pattern matching the version suffix commonly appended to jar filenames.
# The pattern matches conventional versions (e.g., "hamcrest-1.2.jar") and
# unconventional revisioned versions (e.g., "jarjar-1.0rc8.jar"). Note that, due
# to simplicity, the pattern may ocassionally match more than you want!
#JAVA_JAR_SED_VERSION_PATTERN='-[0-9].*\.jar'

# ....................{ EXHERES GLOBALS                    }....................
# Add a buildtime dependency on "app-arch/zip" to all Ant exheres. The
# "replace_jar_manifest" function implicitly requires this binary. While many
# Java exheres do not call this function, many others do; as this is a common
# dependency of other core exheres, our adding it here should do little harm.
DEPENDENCIES+="
    build:
        app-arch/zip
"

# ....................{ PHASES                             }....................
javafix_pkg_setup() {
    default
    echo ">>> Setting up exheres defaults"

    # Die if the currently selected Java compiler is exheres restricted.
    if [[ -n "${JAVA_RESTRICT_JDK_PREFIXES[@]}" ]]; then
        local JAVA_RESTRICT_JDK_PREFIX
        for   JAVA_RESTRICT_JDK_PREFIX in "${JAVA_RESTRICT_JDK_PREFIXES}"; do
            if [[ "${JAVA_JDK}" = "${JAVA_RESTRICT_JDK_PREFIX}"* ]]; then
                eerror "Your currently selected Java compiler is \"${JAVA_JDK}\". Unfortunately, \"${PNV}\""
                eerror "reports it currently fails under this compiler. Consider installing and enabling"
                eerror "a better supported Java compiler: e.g., \"icedtea6\"."
                die_unless_nonfatal "${PNV} refuses to build under ${JAVA_JDK}"
            fi
        done
    fi

    # Warn if the currently selected Java compiler is GCJ.
    if [[ "${JAVA_JDK}" == gcj* ]]; then
        ewarn "Your currently selected Java compiler is \"gcj\". Unfortunately, this compiler"
        ewarn "violates sydbox network sandboxing by attempting to open spurious DNS requests."
        ewarn "Consider installing and enabling a better supported Java compiler: e.g., \"icedtea6\"."
        JAVA_IS_DISABLING_NETWORK_SANDBOXING=1
    fi

    # Establish the system directory to which we're installing output jar files.
    if [[ -z "${JAVA_SRC_INSTALL_JARS_IMAGE_DIR}" ]]; then
        # Output jar files for slotted exheres must be installed to a slotted
        # subdirectory of this directory. (Exheres for which [[ ${SLOT} -eq 0 ]]
        # are unslotted exheres; all other exheres are slotted.)
        if [[ -z "${SLOT}" ]] || [[ "${SLOT}" -eq 0 ]]
        then JAVA_SRC_INSTALL_JARS_IMAGE_DIR=$(which_installed_jar_dir_nonfatal "${PN}")
        else JAVA_SRC_INSTALL_JARS_IMAGE_DIR=$(which_installed_jar_dir_nonfatal "${PN}:${SLOT}")
        fi
    fi

    # Establish whether we want javadoc installed or not via the "doc" option.
    # Do this in "pkg_setup" as that is the earliest time we may test options.
    if has doc ${MYOPTIONS} && option doc; then
        JAVA_IS_INSTALLING_JAVADOC=1
    fi
}

javafix_src_unpack() {
    default

    # The "ant_src_unpack" function recursively destroys the contents of all
    # paths in "${ANT_BUNDLED_LIBSDIR}". Now, we must not destroy the "${WORK}"
    # path. However, some Java libraries (e.g., Hamcrest) come with jar files
    # pre-bundled in the "${WORK}" path. We thus homebrew this boolean to
    # recursively remove jar files rather than all files and paths, prior to
    # calling the "ant_src_unpack" function.
    if [[ "${JAVA_IS_CLEANING_JAR_FILES}" ]]; then
        echo ">>> Removing jar files"
        clean_jar_files
    fi

    if [[ "${JAVA_IS_CLEANING_CLASS_FILES}" ]]; then
        echo ">>> Removing class files"
        clean_class_files
    fi
}

javafix_src_prepare() {
    javafix_src_preamble
    default

    # Deversion files after patching files above but before invoking Ant below.
    if [[ -n "${JAVA_SRC_PREPARE_DEVERSION_FILES[@]}" ]]; then
        echo ">>> Removing jar filename version specifiers"
        deversion_java_files "${JAVA_SRC_PREPARE_DEVERSION_FILES[@]}"
    fi

    if [[ -n "${JAVA_SRC_PREPARE_SYMLINK_JARS[@]}" ]]; then
        echo ">>> Linking external jar files"
        set_symlink_jar_dir "${JAVA_SRC_PREPARE_SYMLINK_DIR}"
        symlink_jars        "${JAVA_SRC_PREPARE_SYMLINK_JARS[@]}"
    fi
}

javafix_src_configure() {
    javafix_src_preamble
}

javafix_src_compile() {
    javafix_src_preamble
}

javafix_src_test() {
    javafix_src_preamble
}

javafix_src_install() {
    javafix_src_preamble

    echo ">>> Installing documents"
    emagicdocs

    # Also ensure we generate javadoc if the user enabled the "doc" option and
    # this exheres specified a directory having generated javadoc. (That's a few
    # ifs.)
    if [[ -n "${JAVA_IS_INSTALLING_JAVADOC}" ]] &&
       [[ -n "${JAVA_SRC_INSTALL_JAVADOC_DIR}" ]]; then
        echo ">>> Installing javadoc"
        docinto "html/javadoc"
        dodoc "${JAVA_SRC_INSTALL_JAVADOC_DIR}"/*
    fi

    if [[ -n "${JAVA_SRC_INSTALL_JARS[@]}" ]]; then
        echo ">>> Installing jar files"
        install_jars "${JAVA_SRC_INSTALL_JARS[@]}"
    fi
}

javafix_src_preamble() {
    if [[ -n "${JAVA_IS_DISABLING_NETWORK_SANDBOXING}" ]]; then
        ewarn "Disabling network sandboxing..."
        sydboxcmd 'sandunbox/net'
    fi
}

# ....................{ CLEANERS                           }....................
# void disable_class_file_cleaning(void)
#
# Disable recursive deletion of all class files under ${WORK} in "src_unpack".
# Calling this function is preferable to explicitly unsetting the global.
disable_class_file_cleaning() {
    unset JAVA_IS_CLEANING_CLASS_FILES
}

# void disable_jar_file_cleaning(void)
#
# Disable recursive deletion of all jar files under ${WORK} in "src_unpack".
# Calling this function is preferable to explicitly unsetting the global.
disable_jar_file_cleaning() {
    unset JAVA_IS_CLEANING_JAR_FILES
}

# void clean_jar_files(void)
#
# Recursively remove all jar files under ${WORK}. (Fairly destructive!)
clean_jar_files() {
    # Do not use "edo rm -f "${WORK}"/**/*.jar" as that tends to glob more
    # files than can be reasonably handled by the shell.
    edo find "${WORK}" -type f -iname '*.jar' \
        "${JAVA_CLEAN_JAR_FILES_PARAMS[@]}" -delete
}

# void clean_class_files(void)
#
# Recursively remove all class files under ${WORK}. (Danger, Exherbon.)
clean_class_files() {
    edo find "${WORK}" -type f -iname '*.class' -delete
}

# ....................{ DEVERSIONERS                       }....................
# void deversion_java_files(char *filename1, char *filename2, ...)
#
# Patch the passed absolute or relative filenames of jar file version suffixes.
# These files are typically "build.xml" files, so as to generalize their build
# process to non-versioned jar files installed on the local machine.
deversion_java_files() {
    local EPN
    local DEVERSION_JAVA_FILE
    for   DEVERSION_JAVA_FILE in ${*}; do
        # Implicitly remove filename version specifiers matching:
        # "-${DSTAMP}.jar", "-${TSTAMP}.jar", or "-${TODAY}.jar". These
        # are Ant properties generated by the "tstamp" task and, when
        # used in jar filenames, mostly produce badly named jar files.
        #
        # This should be safe... should.
        edo sed -i "${DEVERSION_JAVA_FILE}" \
            -r -e 's~-\$\{(DSTAMP|TSTAMP|TODAY)\}\.jar~.jar~'

        # Explicitly remove filename version specifiers only for externally
        # symlinked jar files, where the 'E' in "EPN" stands for external.
        #
        # Do not remove version specifiers from other jar filenames as those
        # filenames may not actually exist. As we can't be sure, we don't.
        if [[ -n "${JAVA_SRC_PREPARE_SYMLINK_JARS[@]}" ]]; then
            for EPN in "${JAVA_SRC_PREPARE_SYMLINK_JARS[@]}"; do
                if [[ "${EPN:0:1}" != / ]]; then  # ignore absolute paths
                    edo sed -i "${DEVERSION_JAVA_FILE}" \
                        -r -e "s~${EPN}${JAVA_JAR_VERSION_PATTERN}~${EPN}.jar~"
                fi
            done
        fi
    done
}

# ....................{ SYMLINKERS                         }....................
# The following convenience functions symbolically link external Java libraries
# into the current exhere's work directory prior to compilation of that exheres.

# void set_symlink_jar_dir(char *pathname)
#
# Set the path of the directory into which external jar files should be
# symbolically linked for this exheres. The "build.xml" file for this exheres
# presumably requires these external jar files to be present in this directory
# prior to operation. The "prepare_jar*" family of functions, below, operate on
# this directory until the next invocation of this function.
#
# If absolute, no path processing is performed upon the filename aside from
# ensuring that this path resides under "${WORK}/"; if relative, the absolute
# path "${WORK}/" is prepended to this path.
#
# By convention, this is usually just "lib". Most Java libraries are different,
# of course.
set_symlink_jar_dir() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "one and only one argument needed"

    JAVA_SRC_PREPARE_SYMLINK_DIR="${1}"

    # If we were passed an absolute path, test it.
    if [[ ${JAVA_SRC_PREPARE_SYMLINK_DIR:0:1} == / ]]; then
        [[ "${JAVA_SRC_PREPARE_SYMLINK_DIR}" == "${WORK}"* ]] ||
            die_unless_nonfatal "${JAVA_SRC_PREPARE_SYMLINK_DIR} not under ${WORK}"
    # If we were passed a relative path, canonicalize it.
    else
        JAVA_SRC_PREPARE_SYMLINK_DIR="${WORK}/${JAVA_SRC_PREPARE_SYMLINK_DIR}"
    fi

    # If the path exists, remove all jar files the archive extracted into it.
    # This provides a convenient alternative to the rather cumbersome
    # "${JAVA_BUNDLED_LIBSDIR}" array.
    if [[ -d "${JAVA_SRC_PREPARE_SYMLINK_DIR}" ]]; then
        edo rm -f "${JAVA_SRC_PREPARE_SYMLINK_DIR}"/*.jar
    # Otherwise create the path. It should already be, in general.
    else
        edo install -d "${JAVA_SRC_PREPARE_SYMLINK_DIR}"
    fi

    # Notify the world!
    export JAVA_SRC_PREPARE_SYMLINK_DIR
}

# void symlink_jars(char *jar_spec1, char *jar_spec2, ...)
#
# Symbolically link jar specificiers to relative filenames having same basename
# under the above directory, where "jar specificiers" are strings specifying
# external jar files already installed to the local system by another exheres
# on which this exheres depends. These strings are usually, but not always,
# absolute or relative paths:
#
# * If an absolute path, that path is symlinked as is without modification.
# * If a string having no whitespace, this string signifies both the exheres
#   name (and optional slot) and jar filename. The slot, if present, is
#   demarcated via a colon. (See below.) Then, the absolute path
#   "/usr/share/${exheres_name}/${slot}" is prepended to the string, the type
#   ".jar" is appended to the string, and the final path symlinked. Example:
#
#    # Symbolically links "/usr/share/ecocide/ecocide.jar" into "lib/".
#    symlink_jars("ecocide")
#
#    # Symbolically links "/usr/share/ecocide/4/ecocide.jar" into "lib/".
#    symlink_jars("ecocide:4")
#
#   If the resultant absolute path is not found, this also tries
#   "/usr/share/$(basename ${jar_spec%%-*})/". This is the first part of the
#   passed jar specifier up to but not including the first hyphen. Example:
#
#    # Tries "/usr/share/moa-core/moa-core.jar", which is not found. Then
#    # tries "/usr/share/moa/moa-core.jar", which is found. Finally,
#    # symbolically links "/usr/share/moa/moa-core.jar" into "lib/".
#    symlink_jars("moa-core")
#
# * If a string having whitespace, the string is first split on the first
#   whitespace in that string. The first half of the string signifies the
#   exheres name (and optional slot), while the second half signifies the
#   jar filename as above. The slot, if present, is demarcated from the
#   exheres name via a colon. (See below.) Then, the absolute path
#   "/usr/share/${exheres_name}/${slot}" is prepended to the string, the type
#   ".jar" is appended to the string, and the final path symlinked. Example:
#
#    # Symbolically links "/usr/share/ecocide/1080.jar" into "lib/".
#    symlink_jars("ecocide" "1080")
#
#    # Symbolically links "/usr/share/ecocide/1.2/1080.jar" into "lib/".
#    symlink_jars("ecocide:1.2" "1080")
#
# This function is usually clever enough to suss out the absolute path to
# whatever you pass it. When it doesn't, simply pass the absolute path.
symlink_jars() {
    illegal_in_global_scope
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"
    [[ -d "${JAVA_SRC_PREPARE_SYMLINK_DIR}" ]] ||
        die_unless_nonfatal "${JAVA_SRC_PREPARE_SYMLINK_DIR} not found or not set"

    local JAR_SPEC EXHERES_NAME JAR_FILENAME
    for   JAR_SPEC in ${*}; do
        # If an absolute path, use as is.
        if [[ "${JAR_SPEC:0:1}" = / ]]; then
            INSTALLED_JAR_FILE="${JAR_SPEC}"
        # Otherwise, get the absolute path.
        else
            # If split on whitespace, grep the exheres name from jar filename in
            # the passed jar specifier via Bash regexp matching.
            if [[ "${JAR_SPEC}" =~ ^([^[:space:]]+)[[:space:]]+(.+)$ ]]; then
                INSTALLED_JAR_FILE=$(which_installed_jar_file_nonfatal "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")
            # Otherwise, the jar filename is the passed jar specifier.
            else
                INSTALLED_JAR_FILE=$(which_installed_jar_file_nonfatal "${JAR_SPEC}" "${JAR_SPEC}")

                # If not found but has a hyphen, grep the exheres name again.
                if [[ ! -f "${INSTALLED_JAR_FILE}" ]] &&
                   [[ "${JAR_SPEC}" =~ ^([^-]+)- ]]; then
                   INSTALLED_JAR_FILE=$(which_installed_jar_file_nonfatal "${BASH_REMATCH[1]}" "${JAR_SPEC}")
                fi
            fi
        fi

        [[ -f "${INSTALLED_JAR_FILE}" ]] ||
            die_unless_nonfatal "${INSTALLED_JAR_FILE} not found"
        edo ln -s "${INSTALLED_JAR_FILE}" "${JAVA_SRC_PREPARE_SYMLINK_DIR}"/
    done
}

# ....................{ INSTALLERS                         }....................
# The following convenience functions install all Java libraries produced by
# this exheres into local directories appropriate for this exheres.

# void install_jars(char *filename1, char *filename2, ...)
#
# Copy absolute filenames to relative filenames having the same basename sans
# version under the above directory. By "sans version", we mean basename minus
# "-${PV}". Jar filenames should be versionless so as to permit their usage
# elsewhere without concern for the specific versions they represent. This
# resembles:
#
#   cp "$filename1" "$filename2" ... "${IMAGE}/${JAVA_SRC_INSTALL_JARS_IMAGE_DIR}"
install_jars() {
    illegal_in_global_scope
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"
    install_jar_preamble

    insinto "${JAVA_SRC_INSTALL_JARS_IMAGE_DIR}"

    local INSTALL_JAR_FILE
    for   INSTALL_JAR_FILE in ${*}; do
        # Strip versions from filenames: e.g., convert "zebrapig-0.42.jar" to
        # "zebrapig.jar". The pattern substitution requires the bash "extglob"
        # shell option be enabled, which it is under exheres-0.
        #
        # See "man bash" for details.
        newins ${INSTALL_JAR_FILE} \
            $(basename "${INSTALL_JAR_FILE/${JAVA_JAR_PARAMETER_VERSION_PATTERN}/.jar}")
    done
}

# void install_jar_as(char *filename1, char *filename2)
#
# Copy absolute "$filename1" to relative "$filename2" under the above directory.
# This is functionally equivalent to:
#
#   cp "$filename1" "${IMAGE}/$install_jar_dir/$filename2"
install_jar_as() {
    illegal_in_global_scope
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "exactly two arguments needed"
    install_jar_preamble

    local JAR_FILE_IN="${1}"
    local JAR_FILE_OUT="${2}"
    [[ "${JAR_FILE_OUT}" =~ ${JAVA_JAR_VERSION_PATTERN}$ ]] &&
        ewarn "${JAR_FILE_OUT} contains a version specifier"

    insinto "${JAVA_SRC_INSTALL_JARS_IMAGE_DIR}"
    newins "${JAR_FILE_IN}" "${JAR_FILE_OUT}"
}

# void install_jar_preamble(char *filename1, char *filename2)
#
# Ensures sanity when calling "install_jar*" functions.
install_jar_preamble() {
    illegal_in_global_scope
    [[ -n "${JAVA_SRC_INSTALL_JARS_IMAGE_DIR}" ]] ||
        die_unless_nonfatal "\"JAVA_SRC_INSTALL_JARS_IMAGE_DIR not set\"; was \"javafix_pkg_setup\" called?"
    [[ "${JAVA_SRC_INSTALL_JARS_IMAGE_DIR}" =~ ^/(usr|opt)/ ]] ||
        die_unless_nonfatal "\"${JAVA_SRC_INSTALL_JARS_IMAGE_DIR}\" not under /usr or /opt"
}

# char *which_installed_jar_dir(char *exheres_name)
#
# Given an exheres name and optional slot, returns the absolute path to the
# installed directory having jar files for that exheres: e.g.,
#
#     # Echoes "/usr/share/turkish_dream".
#     echo $(which_installed_jar_dir "turkish_dream")
#     # Echoes "/usr/share/british_moors/2.5".
#     echo $(which_installed_jar_dir "british_moors:2.5")
#
# Append the exheres slot to the exheres name as in "DEPENDENCIES": e.g.,
# "${PN}:${SLOT}". A slot need not be specified, of course. See examples.
#
# For safety, this function dies when the path does not exist.
which_installed_jar_dir() {
    local    JAR_DIR=$(which_installed_jar_dir_nonfatal ${*})
    [[ -d "${JAR_DIR}" ]] || die_unless_nonfatal "${JAR_DIR} not found"
    echo  "${JAR_DIR}"
}

# char *which_installed_jar_dir_nonfatal(char *exheres_name)
#
# Identical to "which_installed_jar_dir" but does not ensure the path exists.
which_installed_jar_dir_nonfatal() {
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "exactly one argument needed"
    [[ -n "${1}"  ]] || die_unless_nonfatal "non-null argument needed"

    # Bash regex matching trailing slot number. Note hardcoded jar file
    # installation to subdirectories of "/usr/share", which is always where we
    # want them so that other exheres may find them.
    if [[ "${1}" =~ ^(.+):([^:]+)$ ]]
    then echo "/usr/share/${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
    else echo "/usr/share/${1}"
    fi
}

# char *which_installed_jar_file(char *jar_file)
# --OR--
# char *which_installed_jar_file(char *exheres_name, char *jar_file)
#
# Given a jar file and optional exheres name and slot, returns the absolute path
# to that jar file as installed on the local system: e.g.,
#
#     # Echoes "/usr/share/hamcrest/hamcrest-library.jar".
#     echo $(which_installed_jar_file "hamcrest-library")
#     # Echoes "/usr/share/raki-saki/raki-saki-core.jar".
#     echo $(which_installed_jar_file "dist/lib/raki-saki-core.5.22.jar")
#     # Echoes "/usr/share/raki-saki/org.turkish.dream.jar".
#     echo $(which_installed_jar_file "raki-saki" "bin/org.turkish.dream-0.1.3.jar")
#     # Echoes "/usr/share/raki-saki/8/org.turkish.dream.jar".
#     echo $(which_installed_jar_file "raki-saki:8" "bin/org.turkish.dream-0.1.3.jar")
#
# Append the exheres slot to the exheres name as in "DEPENDENCIES": e.g.,
# "${PN}:${SLOT}". A slot need not be specified, of course. See examples.
#
# This automatically strips version strings from passed jar filenames as well as
# establishing the expected parent directory. As above, for safety, this
# function dies when the file does not exist.
which_installed_jar_file() {
    local    JAR_FILE=$(which_installed_jar_file_nonfatal ${*})
    [[ -f "${JAR_FILE}" ]] || die_unless_nonfatal "${JAR_FILE} not found"
    echo  "${JAR_FILE}"
}

# char *which_installed_jar_file_nonfatal(char *jar_file)
# --OR--
# char *which_installed_jar_file_nonfatal(char *exheres_name, char *jar_file)
#
# Identical to "which_installed_jar_file" but does not ensure the file exists.
which_installed_jar_file_nonfatal() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] ||
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "one or two arguments needed"
    [[ -n "${1}"  ]] || die_unless_nonfatal "non-null argument needed"

    local JAR_FILENAME EXHERES_NAME

    if   [[ ${#} -eq 1 ]]
    then JAR_FILENAME="${1}"
    else JAR_FILENAME="${2}"; EXHERES_NAME="${1}"
    fi

    local JAR_BASENAME="${JAR_FILENAME##*/}"   # filename sans path
    local JAR_ROOTNAME="${JAR_BASENAME%.jar}"  # filename sans path and type

    if [[ -z "${EXHERES_NAME}" ]]
    then EXHERES_NAME="${JAR_ROOTNAME}"
    fi

    # "JAR_ROOTNAME" could still contain a suffixing ":" slot number, however;
    # as no jar file should, cut that if found.
    local JAR_TRUENAME="${JAR_ROOTNAME%:*}"    # filename sans path, type, slot
    echo $(which_installed_jar_dir_nonfatal "${EXHERES_NAME}")"/${JAR_TRUENAME}.jar"
}

# ....................{ MANIFEST.MF                        }....................
# void replace_jar_manifest(char *jar_filename, char *manifest_filename)
#
# Replace "META-INF/MANIFEST.MF" in the passed jar filename with the passed
# manifest filename. Also, substitute placeholder variables with their current
# Bash values as performed by the "rectify_jar_manifest" function.
#
# Exheres usually call this function from "${PN}_src_install", often overriding
# exheres globals with jar file-specific locals: e.g.,
#
#     local PV=0.8.1   # ...hides the global ${PV}
#     replace_jar_manifest "dist/${PN}.jar" "${FILES}/${PN}-MANIFEST.MF"
replace_jar_manifest() {
    illegal_in_global_scope
    [[ ${#} -eq 2        ]] || die_unless_nonfatal "exactly two arguments needed"
    [[ -x "/usr/bin/zip" ]] || die_unless_nonfatal "zip not installed"

    local      JAR_FILE="${1}"
    local MANIFEST_FILE="${2}"

    # Copy the source to target manifest file, and patch placeholders.
    edo mkdir -p              "${TEMP}/META-INF"
    edo cp "${MANIFEST_FILE}" "${TEMP}/META-INF/MANIFEST.MF"
    rectify_jar_manifest      "${TEMP}/META-INF/MANIFEST.MF"

    # Move the jar file to the temporary path having the target manifest,
    # temporarily renaming it for convenience.
    edo mv "${JAR_FILE}" "${TEMP}/jar.jar"

    # The activated JDK necessarily installs a "jar" binary. This binary permits
    # updating, but not replacement, of existing jar file manifest files. That's
    # not what we want; so, unfortunately, we depend on the "zip" binary. This
    # binary is not guaranteed to be installed; when installed, it requires we
    # we change directories.
    edo pushd "${TEMP}"
    edo zip -q "jar.jar" "META-INF/MANIFEST.MF"

    # Get us home, Commander Gaeta.
    edo popd

    # Move the jar file to its original path.
    edo mv "${TEMP}/jar.jar" "${JAR_FILE}"
}

# void rectify_jar_manifest(char *manifest_filename)
#
# Patch contents of the passed manifest filename or "META-INF/MANIFEST.MF" from
# the current directory, if no manifest filename is passed. In particular,
# substitute placeholder variables in the manifest with their current values.
# Recognized placeholders are:
#
# * __PV__, which will be substituted with ${PV}.
# * %bundleName, which will be substituted with ${BUNDLE_NAME}
# * %providerName, which will be substituted with ${PROVIDER_NAME}
#
# Placeholder variables prefixed by '%' are specific to the Java OSGI standard.
# Placeholder variables enclosed by '__' are specific to this function, and
# chosen so as to avoid conflicting with existing manifest file text.
#
# Exheres usually call this function from "${PN}_src_prepare", often overriding
# exheres globals with jar file-specific locals: e.g.,
#
#     local PV=3.0.2                   # ...hides the global ${PV}
#     local BUNDLE_NAME="SAT4J Core"   # ...hides the global ${BUNDLE_NAME}
#     rectify_jar_manifest "${WORK}/build/META-INF/MANIFEST.MF"
#
# !!!!!IMPORTANT!!!!! strings substituted into placeholder variables must not
# contain backtick characters '`', as the sed expressions performing these
# substitutions use that character to delimit themselves. Since this would be a
# strange character for a string to contain, this is generally "safe."
rectify_jar_manifest() {
    illegal_in_global_scope
    [[ ${#} -le 1 ]] || die_unless_nonfatal "zero or one arguments needed"

    local MANIFEST_FILE="${1:-META-INF/MANIFEST.MF}"
    local PROVIDER_NAME="${PROVIDER_NAME:-Exherbo!}"

    # Substitute placeholder variables, with undefined variables simply
    # expanding to the empty string.
    edo sed -i "${MANIFEST_FILE}" \
        -e "s\`__PV__\`${PV}\`" \
        -e "s\`%bundleName\`${BUNDLE_NAME}\`" \
        -e "s\`%providerName\`${PROVIDER_NAME}\`"
}

