# Copyright 2010 Cecil Curry <leycec@gmail.com>
# Distributed under the terms of the GNU General Public License v2
#
# --------------------( SYNOPSIS                           )--------------------
# This exlib improves "java.exlib" with handling for command-line properties,
# external dependencies, and jar and javadoc installation. These improvements
# should be backported into "java.exlib" where deemed appropriate.
#
# This exlib is thus backwards compatible with other exlibs and exheres
# requiring "java.exlib".
#
# --------------------( ETYMOLOGY                          )--------------------
# Technically, an javafix is "an ornament of the cymatium of a classic cornice,
# sometimes pierced for the escape of water." In reality, I'm not sure I know
# what a cymatium is. Or a cornice.

# ....................{ EXHERES                            }....................
require java
export_exlib_phases pkg_setup \
    src_unpack src_prepare src_configure src_compile src_test src_install

# ....................{ CONFIGURATION                      }....................
# Array of Java JDK prefixes. If the following expression is true for at least
# one ${JAVA_RESTRICT_JDK_PREFIX} of this array, then installation fails
# prior to performing any work:
#
#     [[ $(eclectic java-jdk show) = "${JAVA_RESTRICT_JDK_PREFIX}"* ]]
#
# Example for exheres failing under "gcj" or "gij":
#
#     JAVA_RESTRICT_JDK_PREFIXES=( gcj )
#
# As of mid 2010, all Ant exheres should test compilation under "gcj". Many will
# fail! Those that do must set this array, as above.
JAVA_RESTRICT_JDK_PREFIXES=( )

# Find parameters to be passed to the command-line invocation of "find" when
# cleaning jar files from ${WORK}. Specify this to prevent cleaning of wanted,
# specific jar files: e.g.,
#
#     JAVA_CLEAN_JAR_FILES_PARAMS=( -not -wholename 'bootstrap/young_lad.jar' )
JAVA_CLEAN_JAR_FILES_PARAMS=( )

# Absolute or relative path under ${WORK} into which external jar files will
# be symlinked. Though this path is usually "lib" for most exheres, you must
# still explicitly specify it to have symlinking performed for you. Example:
#
#     JAVA_SRC_LIBRARY_DIR="lib"
JAVA_SRC_LIBRARY_DIR=""

# Array of absolute paths to or relative names of external jar files to be
# symlinked into ${JAVA_SRC_LIBRARY_DIR} during the "src_prepare" phase.
# External jar files should be buildtime dependencies of this exheres. An
# example mixing both absolute paths to and relative names of external files:
#
#     JAVA_SRC_PREPARE_JARS=( jarjar qdox "/usr/share/asm/asm.jar" )
#
# If filenames are not known until install time, leave this array blank and
# call "symlink_jars" within your "src_prepare" function.
JAVA_SRC_PREPARE_JARS=( )

# Array of absolute paths to or relative names of external jar files to be
# symlinked into ${JAVA_SRC_LIBRARY_DIR} during the "src_test" phase.
# External jar files should be test-time dependencies of this exheres. An
# example with slotted dependencies:
#
#     JAVA_SRC_TEST_JARS=( "junit:4" )
#
# If filenames are not known until install time, leave this array blank and
# call "symlink_jars" within your "src_test" function.
JAVA_SRC_TEST_JARS=( )

# Array of absolute paths to text files to be "deversion"-ated. Ant "build.xml"
# files often hardcode references to pre-bundled jar files with names suffixed
# by a version specifier. This is bad, as this exlib replaces all pre-bundled
# jar files with externally symlinked jar files with names NEVER EVER suffixed
# by a version specifier. To resolve the discrepancy, we could do one of two
# ugly hacks:
#
# * Sed affected "build.xml" files, removing jar filename version specifiers OR
# * Grep affected "build.xml" files for these version specifiers and, when
#   symlinking in external jar files, add the version specifier for each jar
#   filename to its symlink filename.
#
# The first is easier. And easier is better. So that's what we do. Example
# deversioning two files, "build.xml" and "common-build.xml":
#
#     JAVA_SRC_PREPARE_DEVERSION_FILES=( "${JAVA_BUILD_XML}" "common-build.xml" )
JAVA_SRC_PREPARE_DEVERSION_FILES=( )

# Absolute path or relative path under ${WORK} into which HTML API documentation
# will be generated by the ${JAVA_BUILD_XML} file for this exheres. This is
# usually "javadoc" for most exheres, but must be explicitly specified to have
# have installation of these files performed for you. Example:
#
#     JAVA_SRC_INSTALL_JAVADOC_DIR="javadoc"
JAVA_SRC_INSTALL_JAVADOC_DIR=""

# Array of absolute paths to this exheres' output jar files to be installed
# under "$(which_installed_jar_dir_for_this_exheres)", with suffixing versions
# automatically removed from filenames on your behalf. Example:
#
#     JAVA_SRC_INSTALL_JARS=( "dist/${PNV}.jar" "dist/${PNV}-library.jar" )
#
# If filenames are not known until install time, leave this blank and explicitly
# call "install_jars" within your "src_install".
JAVA_SRC_INSTALL_JARS=( )

# Associative array mapping jar specifier to absolute or relative path under
# ${WORK} having a "MANIFEST.MF" file to be added to the jar file corresponding
# to that jar specifier. The jar file will have its "META-INF/MANIFEST.MF" file
# replaced by the specified "MANIFEST.MF" file, and then be installed to its
# appropriate place in the filesystem. This array therefore replaces the
# ${JAVA_SRC_INSTALL_JARS} array for exheres requiring both jar file
# installation and jar file "MANIFEST.MF" replacement. Example:
#
#     JAVA_SRC_INSTALL_JARS_WITH_MANIFESTS=(
#         "dist/${PNV}.jar"          "${FILES}/${SLOT}/MANIFEST.MF"
#         "dist/${PNV}-library.jar"  "${FILES}/${SLOT}/MANIFEST-library.MF"
#     )
#
# Note this is a "fake" associative array. While Bash 4.0 does implement support
# for associative arrays, it has no mechanism for reliably passing them to or
# returning them from functions. Fortunately, the "fake" solution works reliably.
#
# If filenames are not known until install time, leave this blank and explicitly
# call "install_jars_with_manifests" within your "src_install".
JAVA_SRC_INSTALL_JARS_WITH_MANIFESTS=( )

# Add a buildtime dependency on "app-arch/zip" to calling exheres. The
# "replace_jar_manifest" function implicitly requires this binary. While many
# Java exheres do not call this function, many others do; as this is a common
# dependency of other core exheres, our adding it here does little harm.
DEPENDENCIES+="
    build:
        app-arch/zip
"

# ....................{ CONSTANTS                          }....................
# This exlib sets these constants on your behalf. Read them; don't write them.
# 
# Scratch that -- don't even read them. If you access these constants in any
# exheres, you're doing something wrong. :)

# Name of the currently selected Java JDK: e.g., "icedtea6", "gcj-jdk". This
# defaults to the empty string here but is set in the "pkg_setup" phase.
JAVA_JDK=

# Version of the currently selected Java JDK: e.g., "1.6", "4.4". This
# defaults to the empty string here but is set in the "pkg_setup" phase.
JAVA_JDK_VERSION=

# Absolute path to the directory having JDK jar files for the above compiler:
# e.g., "rt.jar", "jce.jar".
JAVA_JRE_LIBRARY_DIR="/usr/$(get_libdir)/jre/lib"

# Set, if disabling sydbox's network sandboxing. At the moment, this is only
# enabled when "gcj" is the currently selected Java compiler. This additionally
# implies that "gij" is the currently selected Java interpreter.
#
# Defaults to unset. See the "java_pkg_setup" function for detail.
JAVA_IS_DISABLING_NETWORK_SANDBOXING=

# Set, if recursively deleting all class files from "${WORK}" immediately after
# extracting source tarballs. Such class files are often bundled with tarballs
# to avoid the need for user recompilation. Make them suffer; oh, yes.
#
# Defaults to set.
JAVA_IS_CLEANING_CLASS_FILES=1

# Set, if recursively deleting all jar files from "${WORK}" immediately after
# extracting source tarballs. Such jar files are often bundled with tarballs
# to reduce dependency hell. For us, bundled jar files only aggravate hell.
#
# Defaults to set.
JAVA_IS_CLEANING_JAR_FILES=1

# Set, if calling "default_src_unpack" to perform automated unpacking of
# downloaded archives. Most exheres want this; those that do not (e.g., Eclipse,
# Eclipse SWT) require sufficiently complex unpacking to warrant their doing it
# themselves. (This is not recommended.)
#
# Defaults to set.
JAVA_IS_UNPACKING_ARCHIVES=1

# Bash pattern matching the version suffix commonly appended to jar filenames.
# This pattern matches conventional versions (e.g., "hamcrest-1.2.jar") and
# unconventional revisioned versions (e.g., "jarjar-1.0rc8.jar"). By design,
# this pattern may also be passed without change to "egrep" or "sed -r".
#
# Don't forget to append a '$' if appropriate!
JAVA_JAR_VERSION_PATTERN='-[[:digit:].]+(rc[[:digit:].]+)?\.jar'

# Bash pattern matching the same from within a parameter expansion: e.g.,
#
#    Echoes "harhar.jar".
#    JAR_FILE=harhar-5.62.951.jar && \
#        echo ${JAR_FILE/${JAVA_JAR_PARAMETER_VERSION_PATTERN}/.jar}
JAVA_JAR_PARAMETER_VERSION_PATTERN='%-+([[:digit:].])*(rc+([[:digit:].]))\.jar'

# ....................{ PHASES                             }....................
javafix_pkg_setup() {
    default

    # If ${JAVA_HOME} is not set, then this exheres is probably a JDK that,
    # following installation, will set this. So, don't spit out an error.
    if [[ -n "${JAVA_HOME}" ]]; then
        echo ">>> Checking JDK"
        javafix_check_jdk
    fi
}

javafix_src_unpack() {
    # Call "default_src_unpack", unless the calling exheres has other plans.
    if [[ -n "${JAVA_IS_UNPACKING_ARCHIVES}" ]]; then
        default

        # The "ant_src_unpack" function recursively destroys the contents of all
        # paths in "${ANT_BUNDLED_LIBSDIR}". Now, we must not destroy the "${WORK}"
        # path. However, some Java libraries (e.g., Hamcrest) come with jar files
        # pre-bundled in the "${WORK}" path. We thus homebrew this boolean to
        # recursively remove jar files rather than all files and paths, prior to
        # calling the "ant_src_unpack" function.
        if [[ -n "${JAVA_IS_CLEANING_JAR_FILES}" ]]; then
            echo ">>> Removing jar files"
            clean_jar_files
        fi

        if [[ -n "${JAVA_IS_CLEANING_CLASS_FILES}" ]]; then
            echo ">>> Removing class files"
            clean_class_files
        fi
    fi
}

javafix_src_prepare() {
    javafix_src_preamble
    default

    # Deversion files after patching files above but before invoking Ant below.
    if [[ -n "${JAVA_SRC_PREPARE_DEVERSION_FILES[@]}" ]]; then
        echo ">>> Removing jar filename version specifiers"
        deversion_java_files "${JAVA_SRC_PREPARE_DEVERSION_FILES[@]}"
    fi

    if [[ -n "${JAVA_SRC_PREPARE_JARS[@]}" ]]; then
       [[ -n "${JAVA_SRC_LIBRARY_DIR}" ]] ||
            die_unless_nonfatal "\$JAVA_SRC_LIBRARY_DIR not set; cannot link external jar files"

        # Clean the library directory of all jar files regardless of whether 
        # ${JAVA_IS_CLEANING_JAR_FILES} is disabled or not. These jar files
        # should be replaced by symlinks in the call to "symlink_jars".
        if [[ -d "${JAVA_SRC_LIBRARY_DIR}" ]]; then
            echo ">>> Culling library directory"
            edo rm -f "${JAVA_SRC_LIBRARY_DIR}"/*.jar
        fi

        echo ">>> Linking library jar files"
        symlink_jars "${JAVA_SRC_LIBRARY_DIR}" \
                     "${JAVA_SRC_PREPARE_JARS[@]}"
    fi
}

javafix_src_configure() {
    javafix_src_preamble
}

javafix_src_compile() {
    javafix_src_preamble
}

javafix_src_test() {
    javafix_src_preamble

    if [[ -n "${JAVA_SRC_TEST_JARS[@]}" ]]; then
       [[ -n "${JAVA_SRC_LIBRARY_DIR}" ]] ||
            die_unless_nonfatal "\$JAVA_SRC_LIBRARY_DIR not set; cannot link external jar files"
        echo ">>> Linking test jar files"
        symlink_jars "${JAVA_SRC_LIBRARY_DIR}" \
                     "${JAVA_SRC_TEST_JARS[@]}"
    fi
}

javafix_src_install() {
    javafix_src_preamble

    echo ">>> Installing documents"
    emagicdocs

    if [[ -n "${JAVA_SRC_INSTALL_JAVADOC_DIR}" ]]; then
        echo ">>> Installing javadoc"
        docinto "html/javadoc"
        dodoc "${JAVA_SRC_INSTALL_JAVADOC_DIR}"/*
    fi

    if [[ -n "${JAVA_SRC_INSTALL_JARS[@]}" ]]; then
        echo ">>> Installing jar files"
        install_jars "${JAVA_SRC_INSTALL_JARS[@]}"
    fi

    # Note: it is valid for an exheres to define both ${JAVA_SRC_INSTALL_JARS}
    # and ${JAVA_SRC_INSTALL_JARS_WITH_MANIFESTS}, if that exheres has some
    # output jar files requiring manifest replacement and others not.
    if [[ -n "${JAVA_SRC_INSTALL_JARS_WITH_MANIFESTS[@]}" ]]; then
        echo ">>> Installing jar files with custom manifests"
        install_jars_with_manifests "${JAVA_SRC_INSTALL_JARS_WITH_MANIFESTS[@]}"
    fi
}

javafix_src_preamble() {
    if [[ -n "${JAVA_IS_DISABLING_NETWORK_SANDBOXING}" ]]; then
        ewarn "Disabling network sandboxing..."
        sydboxcmd 'sandunbox/net'
    fi
}

#FIXME: Prefix all function names with "javafix" for safety.
# ....................{ CHECKERS                           }....................
# void check_jdk(void)
#
# Find the currently selected JDK and ensure the current exheres permits
# building against this JDK.
javafix_check_jdk() {
    # Find the currently selected JDK.
    JAVA_JDK=$(readlink -e "${JAVA_HOME}")
    JAVA_JDK="${JAVA_JDK##*/}"

    # Grep the currently selected JDK's version. (Oddly, the "javac -version"
    # emits to stderr rather than stdout. Ehhrm?)
    JAVA_JDK_VERSION=$(javac -version 2>&1 | awk '{print $2}')

    # Die if the currently selected JDK is exheres restricted.
    if [[ -n "${JAVA_RESTRICT_JDK_PREFIXES[@]}" ]]; then
        local JAVA_RESTRICT_JDK_PREFIX
        for   JAVA_RESTRICT_JDK_PREFIX in "${JAVA_RESTRICT_JDK_PREFIXES}"; do
            if [[ "${JAVA_JDK}" = ${JAVA_RESTRICT_JDK_PREFIX}* ]]; then
                die_unless_nonfatal "${PNV} refuses to build under ${JAVA_JDK}"
                break
            fi
        done
    fi

    # Warn if the currently selected JDK is GCJ.
    if [[ "${JAVA_JDK}" == gcj* ]]; then
        ewarn "Your currently selected JDK is \"${JAVA_JDK}\". Unfortunately, this JDK"
        ewarn "violates sydbox network sandboxing by attempting to open spurious DNS requests."
        ewarn "Consider installing and selecting an alternative JDK: e.g., \"icedtea6\"."
        JAVA_IS_DISABLING_NETWORK_SANDBOXING=1
    fi
}

# ....................{ CLEANERS                           }....................
# void clean_jar_files(void)
#
# Recursively remove all jar files under ${WORK}. (Fairly destructive!)
clean_jar_files() {
    # Do not use "edo rm -f "${WORK}"/**/*.jar" as that tends to glob more
    # files than can be reasonably handled by the shell.
    edo find "${WORK}" -type f -iname '*.jar' \
        "${JAVA_CLEAN_JAR_FILES_PARAMS[@]}" -delete
}

# void clean_class_files(void)
#
# Recursively remove all class files under ${WORK}. (Danger, Exherbon.)
clean_class_files() {
    edo find "${WORK}" -type f -iname '*.class' -delete
}

# ....................{ DEVERSIONERS                       }....................
# void deversion_java_files(char *filename1, char *filename2, ...)
#
# Patch the passed absolute or relative filenames of jar file version suffixes.
# These files are typically "build.xml" files, so as to generalize their build
# process to non-versioned jar files installed on the local machine.
deversion_java_files() {
    local LIBRARY_JAR_SPEC LIBRARY_JAR_NAME
    local DEVERSION_JAVA_FILE
    for   DEVERSION_JAVA_FILE in "${@}"; do
        # Implicitly remove filename version specifiers matching:
        # "-${DSTAMP}.jar", "-${TSTAMP}.jar", or "-${TODAY}.jar". These
        # are Ant properties generated by the "tstamp" task and, when
        # used in jar filenames, mostly produce badly named jar files.
        #
        # This should be safe... should.
        edo sed -i "${DEVERSION_JAVA_FILE}" \
            -r -e 's~-\$\{(DSTAMP|TSTAMP|TODAY)\}\.jar~.jar~'

        # Explicitly remove filename version specifiers only for externally
        # symlinked jar files listed in ${JAVA_SRC_PREPARE_JARS}. Note that
        # elements of this list are jar specifiers and must be converted to a
        # proper absolute path so that the basename of that path, which is the
        # jar filename, may be matched against.
        #
        # Do not remove version specifiers from other jar filenames as those
        # filenames may not actually exist. As we can't be sure, we don't.
        if [[ -n "${JAVA_SRC_PREPARE_JARS[@]}" ]]; then
            for LIBRARY_JAR_SPEC in "${JAVA_SRC_PREPARE_JARS[@]}"; do
                LIBRARY_JAR_NAME=$(which_installed_jar_file_from_spec "${LIBRARY_JAR_SPEC}")
                LIBRARY_JAR_NAME="${LIBRARY_JAR_NAME##*/}"
                LIBRARY_JAR_NAME="${LIBRARY_JAR_NAME%.jar}"
                edo sed -i "${DEVERSION_JAVA_FILE}" -r \
                        -e "s~${LIBRARY_JAR_NAME}${JAVA_JAR_VERSION_PATTERN}~${LIBRARY_JAR_NAME}.jar~"
            done
        fi
    done
}

# ....................{ SYMLINKERS                         }....................
# void symlink_jars(char *symlink_dir, char *jar_spec1, char *jar_spec2, ...)
#
# Symlink the passed jar specificiers to relative filenames having the same
# basename in the passed absolute or relative path under ${WORK} to the symlink
# directory. If the path already exists, this function kills all jar files that
# may still exist in it; if it does not, this function creates it. Killing jars
# may be necessary for exheres disabling jar file cleaning and, in any case,
# never hurts. (They are external dependencies, after all.)
#
# Jar specifiers are compact strings uniquely identifying external jar file
# dependencies, as described by the "which_installed_jar_file_from_specifier"
# function. Example:
#
#    # Symlinks "/usr/share/ecocide/ecocide.jar" into "lib/".
#    symlink_jars("lib" "ecocide")
#    # Symlinks "/usr/share/ecocide/4/ecocide.jar" into "lib/".
#    symlink_jars("lib" "ecocide:4")
#    # Tries "/usr/share/moa-core/moa-core.jar", which is not found. Then
#    # tries "/usr/share/moa/moa-core.jar", which is found. Finally,
#    # symlinks "/usr/share/moa/moa-core.jar" into "lib/".
#    symlink_jars("lib" "moa-core")
#    # Symlinks "/usr/share/ecocide/1080.jar" into "lib/".
#    symlink_jars("lib" "ecocide 1080")
#    # Symlinks "/usr/share/ecocide/1.2/1080.jar" into "lib/".
#    symlink_jars("lib" "ecocide:1.2 1080")
#
# For safety, this function dies when the jar to be symlinked does not exist.
symlink_jars() {
    illegal_in_global_scope
    [[ ${#} -ge 2 ]] || die_unless_nonfatal "at least two arguments needed"

    local SYMLINK_DIR="${1}"
    [[ -d "${SYMLINK_DIR}" ]] || edo install -d "${SYMLINK_DIR}"
    shift

    local JAR_SPEC
    for   JAR_SPEC in "${@}"; do
        edo ln -s $(which_installed_jar_file_from_spec "${JAR_SPEC}") \
            "${SYMLINK_DIR}"/
    done
}

# ....................{ INSTALLERS                         }....................
# The following convenience functions install all Java libraries produced by
# this exheres into local directories appropriate for this exheres.

# void install_jars(char *jar_filename1, char *jar_filename2, ...)
#
# Copy the passed jar files to relative filenames having the same basename sans
# version under the installation directory for this exheres: usually,
# "/usr/share/${PN}/${SLOT}/". By "sans version", this means basename minus
# "-${PV}". Installed jar filenames should be versionless to permit their usage
# elsewhere without concern for specific versions they represent. This resembles:
#
#   cp "$filename1" "$filename2" ... "${IMAGE}/${JAVA_SRC_INSTALL_JARS_IMAGE_DIR}"
install_jars() {
    illegal_in_global_scope
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"

    local      JAR_DIR_TARGET=$(which_installed_jar_dir_for_this_exheres)
    insinto "${JAR_DIR_TARGET}"

    local JAR_FILE_SOURCE JAR_FILE_TARGET
    for   JAR_FILE_SOURCE in "${@}"; do
        # Strip versions from filenames: e.g., convert "zebrapig-0.42.jar" to
        # "zebrapig.jar". The pattern substitution requires the bash "extglob"
        # shell option be enabled, which it is under exheres-0.
        #
        # See "man bash" for details.
        JAR_FILE_TARGET=$(basename "${JAR_FILE_SOURCE/${JAVA_JAR_PARAMETER_VERSION_PATTERN}/.jar}")
        echo "cp ${JAR_FILE_SOURCE} ${JAR_DIR_TARGET}/${JAR_FILE_TARGET}"
        newins  "${JAR_FILE_SOURCE}" "${JAR_FILE_TARGET}"
    done
}

# void install_jar_symlinks(char *jar_filename1, char *jar_filename2, ...)
#
# Symlink the passed jar files to relative filenames having the same basename sans
# version under the installation directory for this exheres: usually,
# "/usr/share/${PN}/${SLOT}/".
#
# Passed jar files must already have been installed under ${IMAGE} prior to
# calling this function. Example:
#
#   # Symlinks "/opt/jetty/lib/${PNV}.jar" to
#   # "/usr/share/jetty/${SLOT}/${PN}.jar".
#   insinto "/opt/jetty"
#   doins                           "lib/${PNV}.jar" 
#   install_jar_symlinks "/opt/jetty/lib/${PNV}.jar" 
install_jar_symlinks() {
    illegal_in_global_scope
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"

    local    JAR_DIR_TARGET=$(which_installed_jar_dir_for_this_exheres)
    dodir "${JAR_DIR_TARGET}"

    local JAR_FILE_SOURCE JAR_FILE_TARGET
    for   JAR_FILE_SOURCE in "${@}"; do
        JAR_FILE_TARGET="${JAR_DIR_TARGET}/"$(basename "${JAR_FILE_SOURCE/${JAVA_JAR_PARAMETER_VERSION_PATTERN}/.jar}")
        echo "ln -s ${JAR_FILE_SOURCE} ${JAR_FILE_TARGET}"
        dosym      "${JAR_FILE_SOURCE}" "${JAR_FILE_TARGET}"
    done
}

# void install_jars_with_manifests(
#     char *jar_filename1, char *manifest_filename1,
#     char *jar_filename2, char *manifest_filename2, ...)
#
# Replace the "META-INF/MANIFEST.MF" file in passed jar files with the passed
# manifest files for each; then, copy the resultant jar files to relative
# filenames having the same basename sans version under the installation
# directory for this exheres: usually, "/usr/share/${PN}/${SLOT}/".
install_jars_with_manifests() {
    illegal_in_global_scope
    [[ ${#} -ge 2 ]] || die_unless_nonfatal "at least two arguments needed"

    # Append each passed jar file to ${JAR_FILES} for later installation, and
    # replace the passed manifest file for each passed jar file.
    #
    # Python list comprehensions, eat your pudgy heart out.
    local JAR_FILE MANIFEST_FILE JAR_FILES=( )
    while [[ -n "${@}" ]]; do
        JAR_FILE="${1}"
        MANIFEST_FILE="${2}"
        JAR_FILES+=( "${JAR_FILE}" )
        shift 2

        replace_jar_manifest "${JAR_FILE}" "${MANIFEST_FILE}"
    done

    install_jars "${JAR_FILES[@]}"
}

# void install_jar_as(char *filename1, char *filename2)
#
# Copy absolute "$filename1" to relative "$filename2" under the above directory.
# This is functionally equivalent to:
#
#   cp "$filename1" "${IMAGE}/$install_jar_dir/$filename2"
install_jar_as() {
    illegal_in_global_scope
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "exactly two arguments needed"

    local JAR_FILE_SOURCE="${1}"
    local JAR_FILE_TARGET="${2}"

    # Ignore absolute paths and version specifiers in target jar filenames.
    if [[ ${JAR_FILE_TARGET:0:1} = / ]]; then
        JAR_FILE_TARGET="${JAR_FILE_TARGET##*/}"
    fi
    if [[ "${JAR_FILE_TARGET}" =~ ^(.+)${JAVA_JAR_VERSION_PATTERN}$ ]]; then
        JAR_FILE_TARGET="${BASH_REMATCH[1]}"
    fi

    local      JAR_DIR_TARGET=$(which_installed_jar_dir_for_this_exheres)
    insinto "${JAR_DIR_TARGET}"

    echo "cp ${JAR_FILE_SOURCE} ${JAR_DIR_TARGET}/${JAR_FILE_TARGET}"
    newins "${JAR_FILE_SOURCE}" "${JAR_FILE_TARGET}"
}

# ....................{ LOCATERS                           }....................
# char *which_installed_jar_dir(char *exheres_name)
#
# Given a passed exheres name (with optional slot appended to that name),
# returns the absolute path to the directory into which jar files were earlier
# installed for that exheres: e.g.,
#
#     # Echoes "/usr/share/turkish_dream".
#     echo $(which_installed_jar_dir "turkish_dream")
#     # Echoes "/usr/share/british_moors/2.5".
#     echo $(which_installed_jar_dir "british_moors:2.5")
#
# Append the exheres slot to the exheres name as in "DEPENDENCIES": e.g.,
# "${PN}:${SLOT}". A slot need not be specified, of course.
#
# For safety, this function dies when the path does not exist.
which_installed_jar_dir() {
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "one argument needed"

    local    JAR_DIR=$(which_installed_jar_dir_nonfatal "${@}")
    [[ -d "${JAR_DIR}" ]] || die_unless_nonfatal "${JAR_DIR} not found"
    echo  "${JAR_DIR}"
}

# char *which_installed_jar_dir_nonfatal(char *exheres_name)
#
# Like "which_installed_jar_dir" but does not die when the path does not exist.
# Avoid calling this function; it is unsafe, and intended only as a utility.
which_installed_jar_dir_nonfatal() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "one arguments needed"

    # Install jar files to possibly slotted subdirectories under "/usr/share".
    # Exheres matching this Bash regex are slotted exheres.
    if [[ "${1}" =~ ^(.+):([^:]+)$ ]]
    then echo "/usr/share/${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
    else echo "/usr/share/${1}"
    fi
}

# char *which_installed_jar_file(char *jar_file)
# --OR--
# char *which_installed_jar_file(char *exheres_name, char *jar_file)
#
# Given a jar file and optional exheres name and slot, returns the absolute path
# to that jar file as installed on the local system: e.g.,
#
#     # Echoes "/usr/share/hamcrest/hamcrest-library.jar".
#     echo $(which_installed_jar_file "hamcrest-library")
#     # Echoes "/usr/share/raki-saki/raki-saki-core.jar".
#     echo $(which_installed_jar_file "dist/lib/raki-saki-core.5.22.jar")
#     # Echoes "/usr/share/raki-saki/lib/org.turkish.dream.jar".
#     echo $(which_installed_jar_file "raki-saki" "lib/org.turkish.dream-0.1.3.jar")
#     # Echoes "/usr/share/raki-saki/8/lib/org.turkish.dream.jar".
#     echo $(which_installed_jar_file "raki-saki:8" "lib/org.turkish.dream-0.1.3.jar")
#
# Append the exheres slot to the exheres name as in "DEPENDENCIES": e.g.,
# "${PN}:${SLOT}". A slot need not be specified, of course. See examples.
#
# This automatically strips version strings from passed jar filenames as well as
# establishing the expected parent directory. As above, for safety, this
# function dies when the file does not exist.
which_installed_jar_file() {
    local    JAR_FILE=$(which_installed_jar_file_nonfatal "${@}")
    [[ -f "${JAR_FILE}" ]] || die_unless_nonfatal "${JAR_FILE} not found"
    echo  "${JAR_FILE}"
}

# char *which_installed_jar_file_nonfatal(char *jar_file)
# --OR--
# char *which_installed_jar_file_nonfatal(char *exheres_name, char *jar_file)
#
# Like "which_installed_jar_file" but does not die when the file does not exist.
#
# Avoid calling this function from exheres; it is a utility function intended to
# be called from functions in this exlib.
which_installed_jar_file_nonfatal() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] ||
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "one or two arguments needed"
    [[ -n "${1}"  ]] || die_unless_nonfatal "non-null argument needed"

    local JAR_FILENAME EXHERES_NAME

    if   [[ ${#} -eq 1 ]]
    then JAR_FILENAME="${1}"
    else JAR_FILENAME="${2}"; EXHERES_NAME="${1}"
    fi

    local JAR_BASENAME                         # filename sans absolute path
    if [[ ${JAR_FILENAME:0:1} = / ]]; then
        ewarn "\"${JAR_FILENAME}\" not a relative jar filename; ignoring path"
        JAR_BASENAME="${JAR_FILENAME##*/}"
    else
        JAR_BASENAME="${JAR_FILENAME}"
    fi

    local JAR_ROOTNAME="${JAR_BASENAME%.jar}"  # filename sans path and type

    if [[ -z "${EXHERES_NAME}" ]]
    then EXHERES_NAME="${JAR_ROOTNAME}"
    fi

    # ${JAR_ROOTNAME} could still contain a ':'-suffixed slot number. (Cut that.)
    local JAR_TRUENAME="${JAR_ROOTNAME%:*}"    # filename sans path, type, slot
    echo $(which_installed_jar_dir_nonfatal "${EXHERES_NAME}")"/${JAR_TRUENAME}.jar"
}

# ....................{ LOCATERS ~~ this exheres           }....................
# char *which_installed_jar_dir_for_this_exheres(void)
#
# Returns the absolute path to the directory into which jar files will be
# installed for the current exheres:
#
#     # Echoes "/usr/share/clathrate_gun/1" assuming this exheres is named
#     # "clathrate_gun" and slotted with 1.
#     echo $(which_installed_jar_dir_for_this_exheres)
#
# This function does not die when the path does not exist, since this function
# is usually called from the "src_install" phase prior to creation of the path.
which_installed_jar_dir_for_this_exheres() {
    [[ ${#} -eq 0 ]] || die_unless_nonfatal "no arguments needed"
    which_installed_jar_dir_nonfatal $(get_java_exheres_name_for_this_exheres)
}

# char *which_installed_jar_file_for_this_exheres(void)
#
# Returns the absolute path to the jar file to be installed for the current
# exheres: e.g.,
#
#     # Echoes "/usr/share/clathrate_gun/1/clathrate_gun.jar" assuming this
#     # exheres is named "clathrate_gun" and slotted with 1.
#     echo $(which_installed_jar_file_for_this_exheres)
#
# This function should only be called from exheres installing a jar file having
# the same name as the exheres name. (Coveniently, this is most of them.)
#
# This function does not die when the file does not exist, since this function
# is usually called from the "src_install" phase prior to creation of the file.
which_installed_jar_file_for_this_exheres() {
    [[ ${#} -eq 0 ]] || die_unless_nonfatal "no arguments needed"
    which_installed_jar_file_nonfatal $(get_java_exheres_name_for_this_exheres)
}

# char *get_java_exheres_name_for_this_exheres(void)
#
# Return this exheres name optionally suffixed by this exheres slot, if given.
# This is a utility function called by the "*_for_this_exheres" functions above.
get_java_exheres_name_for_this_exheres() {
    # Technically, exheres having no slot or a zero slot are unslotted exheres.
    # Nonetheless, this exlib explicitly slots zero slot exheres for forwards
    # compatibility with future releases of those exheres.
    if [[ -z "${SLOT}" ]]
    then echo "${PN}"
    else echo "${PN}:${SLOT}"
    fi
}

# ....................{ LOCATERS ~~ jar specifiers         }....................
# char *which_installed_jar_file_from_spec(char *jar_spec)
#
# Returns the absolute path to the installed jar file corresponding to the
# passed jar specifier. Jar specificiers are exlib-specific compact strings
# uniquely identifying external jar files. Because they are compact, jar
# specifiers are often used to pack jar file descriptions into Bash arrays and
# pass these descriptions between functions. In their simplest form, jar
# specifiers are merely paths; in their most complex, whitespace-delimited
# strings. Specifically,
#
# * If an absolute path, the path is returned as is without modification.
# * If a string having no whitespace, the string signifies both the exheres
#   name and optional slot and jar filename. The slot, if present, is
#   demarcated via a colon. (See below.) Then, the absolute path
#   "/usr/share/${exheres_name}/${slot}" is prepended to the string, the type
#   ".jar" is appended to the string, and the final path is returned. Example:
#
#    # Returns "/usr/share/ecocide/ecocide.jar".
#    which_installed_jar_file_from_spec("ecocide")
#    # Returns "/usr/share/ecocide/4/ecocide.jar".
#    which_installed_jar_file_from_spec("ecocide:4")
#
#   If the resultant path is not found, additionally tries
#   "/usr/share/$(basename ${jar_spec%%-*})/". This is the first part of the
#   passed jar specifier up to but not including the first hyphen. Example:
#
#    # Tries "/usr/share/moa-core/moa-core.jar", which is not found. Then
#    # tries "/usr/share/moa/moa-core.jar", which is found and returned.
#    which_installed_jar_file_from_spec("moa-core")
#
# * If a string having whitespace, the string is split on the first whitespace
#   in that string. The first half of the resultant split signifies the
#   exheres name and optional slot, while the second half signifies the jar
#   filename as above. The slot, if present, is demarcated from the exheres
#   name via a colon. (See below.) Then, the absolute path
#   "/usr/share/${exheres_name}/${slot}" is prepended to the string, the type
#   ".jar" is appended to the string, and the final path is returned. Example:
#
#    # Returns "/usr/share/ecocide/1080.jar".
#    which_installed_jar_file_from_spec("ecocide 1080")
#    # Returns "/usr/share/ecocide/1.2/1080.jar".
#    which_installed_jar_file_from_spec("ecocide:1.2 1080")
#
# This function is usually clever enough to suss out the absolute path to
# whatever you pass it. When it doesn't, simply pass the absolute path.
#
# This function dies if no appropriate jar file can be found.
which_installed_jar_file_from_spec() {
    local    JAR_FILE=$(which_installed_jar_file_from_spec_nonfatal "${@}")
    [[ -f "${JAR_FILE}" ]] || die_unless_nonfatal "${JAR_FILE} not found"
    echo  "${JAR_FILE}"
}

# char *which_installed_jar_file_from_spec_nonfatal(char *jar_spec)
#
# Like "which_installed_jar_file_from_spec" but does not die when the file does
# not exist.
#
# Avoid calling this function from exheres; it is a utility function intended to
# be called from functions in this exlib.
which_installed_jar_file_from_spec_nonfatal() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "exactly one argument needed"

    local JAR_SPEC="${1}"
    local JAR_FILE

    # If an absolute path, use as is.
    if [[ "${JAR_SPEC:0:1}" = / ]]; then
        JAR_FILE="${JAR_SPEC}"
    # Otherwise, get the absolute path.
    else
        # If split on whitespace, grep the exheres name from jar filename in
        # the passed jar specifier via Bash regexp matching.
        if [[ "${JAR_SPEC}" =~ ^([^[:space:]]+)[[:space:]]+(.+)$ ]]; then
            JAR_FILE=$(which_installed_jar_file_nonfatal "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")
        # Otherwise, the jar filename is the passed jar specifier.
        else
            JAR_FILE=$(which_installed_jar_file_nonfatal "${JAR_SPEC}" "${JAR_SPEC}")

            # If not found but has a hyphen, grep the exheres name again.
            if [[ ! -f "${JAR_FILE}" ]] &&
               [[ "${JAR_SPEC}" =~ ^([^-]+)- ]]; then
               JAR_FILE=$(which_installed_jar_file_nonfatal "${BASH_REMATCH[1]}" "${JAR_SPEC}")
            fi
        fi
    fi

    echo "${JAR_FILE}"
}

# ....................{ MANIFEST.MF                        }....................
# void replace_jar_manifest(char *jar_filename, char *manifest_filename)
#
# Replace "META-INF/MANIFEST.MF" in the passed jar filename with the passed
# manifest filename. Also, substitute placeholder variables with their current
# Bash values as performed by the "rectify_jar_manifest" function.
#
# Exheres usually call this function from "src_install", occasionally overriding
# exheres globals with jar file-specific locals: e.g.,
#
#     local PV=0.8.1   # ...hides the global ${PV}
#     replace_jar_manifest "dist/${PN}.jar" "${FILES}/${PN}-MANIFEST.MF"
replace_jar_manifest() {
    illegal_in_global_scope
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "exactly two arguments needed"

    local      JAR_FILE="${1}"
    local MANIFEST_FILE="${2}"

    # Copy the source to target manifest file, and patch placeholders.
    edo mkdir -p              "${TEMP}/META-INF"
    edo cp "${MANIFEST_FILE}" "${TEMP}/META-INF/MANIFEST.MF"
    rectify_jar_manifest      "${TEMP}/META-INF/MANIFEST.MF"

    # Move the jar file to the temporary path having the target manifest,
    # temporarily renaming it for convenience.
    edo mv "${JAR_FILE}" "${TEMP}/temp.jar"

    # All JDKs install a "jar" binary. Most such binaries permit update, but
    # not replacement, of existing jar file manifest files. That is not what we
    # want; so, unfortunately, we depend on the "zip" binary. It is not
    # guaranteed to be installed. Depend on it, above.
    #
    # "zip" requires we we change directories. *sigh*
    edo pushd "${TEMP}"
    edo zip -q "temp.jar" "META-INF/MANIFEST.MF"

    # Get us home, Commander Gaeta.
    edo popd

    # Move the jar file back to its original path.
    edo mv "${TEMP}/temp.jar" "${JAR_FILE}"
}

# void rectify_jar_manifest(char *manifest_filename)
#
# Substitute placeholder variables in the passed manifest file with their
# current values. Recognized placeholders are:
#
# * "__PN__", which will be substituted with ${PN}.
# * "__PV__", which will be substituted with ${PV}.
# * "%bundleName", "%fragmentName", "%pluginName", which will both be
#   substituted with ${BUNDLE_NAME}. If ${BUNDLE_NAME} is not set, defaults to
#   ${PN}. This is O.K.; this variable is usually applied to the "Bundle-Name"
#   manifest key, which, under the OSGi standard, is an optional key for GUI
#   purposes.
# * "%bundleProvider" or "%providerName", which will both be substituted with
#   ${BUNDLE_VENDOR}. If ${BUNDLE_VENDOR} is not set, defaults to "Exherbo!"
#   This is O.K.; this variable is usually applied to the "Bundle-Vendor"
#   manifest key, which, under the OSGi standard, is an optional key.
#
# Placeholder variables prefixed by '%' are specific to the Java OSGi standard.
# Placeholder variables enclosed by '__' are specific to this function, and
# chosen so as to avoid conflicting with existing manifest file text.
#
# Also forcefully replace the value of a "Bundle-Version" manifest key, if
# found, with ${PV}. This is a mandatory OSGi key, which, necessarily, should
# reflect the ${PV} for this exheres. Similarly, replace the contents of strings
# matching 'version="[.[:digit:]]+"' with ${PV}.
#
# Also forcefully delete any lines with manifest keys matching "Name" or
# "SHA1-Digest". These are optional non-OSGi keys, which, when specified, force
# the jar-embedded filename corresponding to the value of "Name" to have an SHA1
# sum evaluating to the value of "SHA1-Digest". Because exheres often apply OSGi
# and non-OSGi manifest files from older versions of the output jar file that
# exheres installs, the actual SHA1 sums of jar-embedded files almost never
# correspond to the manifest values. (Trust us.)
#
# Exheres usually call this function from "${PN}_src_prepare", often overriding
# exheres globals with jar file-specific locals: e.g.,
#
#     local PV=3.0.2                   # ...hides the global ${PV}
#     local BUNDLE_NAME="SAT4J Core"   # ...hides the global ${BUNDLE_NAME}
#     rectify_jar_manifest "${WORK}/build/META-INF/MANIFEST.MF"
#
# !!!!!IMPORTANT!!!!! strings substituted into placeholder variables must not
# contain backtick characters '`', as the sed expressions performing these
# substitutions use that character to delimit themselves. Since this would be a
# strange character for a string to contain, this is generally "safe."
rectify_jar_manifest() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "one argument needed"

    #FIXME leycec: this isn't quite right, but it's close. Continued lines
    #(i.e., long key values continued over several lines) should be temporarily
    #uncontinued prior to performing seding and then recontinued after seding.
    #Then, we should be seding version strings in the "Export-Package" key
    #value (but not the "Import-Package" key value!) with something resembling:
    #   -e "s\`(version=\")[[:digit:].]+\"\`\\1${PV}\"\`g" \

    # Perform the following sed pipeline:
    #
    # {1} Unconditionally convert DOS newlines to Unix newlines. (It happens.)
    # {2} Unconditionally delete whole lines having "bad" keys. Note this also
    #     generates an excess of blank lines, which we later delete. See below.
    #     Also note this deletes the range of all lines between the first "bad"
    #     key of a section and the last "bad" key of the same section; this is
    #     necessary as key values often wrap around to the next line.
    # {3} Unconditionally replace versions with exheres-specific versions.
    # {4} Conditionally replace key values with exheres-specific values.
    # {5} Unconditionally delete consecutive blank lines. Ensure at least one
    #     blank line in a run of blank lines remain, as blank lines in manifest
    #     files are actually syntactically vital: they demarcate sections.
    #
    # What could be simpler? Note that several of these come verbatim from the
    # sed FAQ at http://sed.sourceforge.net/sed1line.txt .
    edo sed -i "${1}" -r \
        -e 's/\r$//' \
        -e '/^Name:[[:space:]]/,/^SHA1-Digest:[[:space:]]/d' \
        -e '/^Bundle-ClassPath:[[:space:]]/d' \
        -e "s\`^(Bundle-Version:[[:space:]]).+$\`\\1${PV}\`" \
        -e "s\`^(implementation-version:[[:space:]]).+$\`\\1${PV}\`" \
        -e "s\`^(Build-JDK:[[:space:]]).+$\`\\1${JAVA_JDK_VERSION}\`i" \
        -e "s\`__PN__\`${PN}\`" \
        -e "s\`__PV__\`${PV}\`" \
        -e "s\`%bundleName\`${BUNDLE_NAME:-${PN}}\`" \
        -e "s\`%fragmentName\`${BUNDLE_NAME:-${PN}}\`" \
        -e "s\`%pluginName\`${BUNDLE_NAME:-${PN}}\`" \
        -e "s\`%bundleProvider\`${BUNDLE_VENDOR:-Exherbo!}\`" \
        -e "s\`%providerName\`${BUNDLE_VENDOR:-Exherbo!}\`" \
        -e '/./,/^$/!d'
}

