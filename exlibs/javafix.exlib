# Copyright 2010 Cecil Curry <leycec@gmail.com>
# Distributed under the terms of the GNU General Public License v2
#
# --------------------( SYNOPSIS                           )--------------------
# This exlib improves "java.exlib" with handling for command-line properties,
# external dependencies, and jar and javadoc installation. These improvements
# should be backported into "java.exlib" where deemed appropriate.
#
# This exlib is thus backwards compatible with other exlibs and exheres
# requiring "java.exlib".
#
# --------------------( ETYMOLOGY                          )--------------------
# Technically, an javafix is "an ornament of the cymatium of a classic cornice,
# sometimes pierced for the escape of water." In reality, I'm not sure I know
# what a cymatium is. Or a cornice.

# ....................{ EXHERES                            }....................
require java
export_exlib_phases pkg_setup \
    src_unpack src_prepare src_configure src_compile src_test src_install

# ....................{ CONFIGURATION                      }....................
# Array of Java JDK prefixes. If the following expression is true for at least
# one ${JAVA_RESTRICT_JDK_PREFIX} of this array, then installation fails
# prior to performing any work:
#     [[ $(eclectic java-jdk show) = "${JAVA_RESTRICT_JDK_PREFIX}"* ]]
#
# Common example for exheres failing under "gcj" or "gij":
#     JAVA_RESTRICT_JDK_PREFIXES=( gcj )
#
# As of mid 2010, all Ant exheres should test compilation under "gcj". Many will
# fail! Those that do should set this array, as above.
JAVA_RESTRICT_JDK_PREFIXES=( )

# Hamcrest does not compile under "gcj", currently.
JAVA_RESTRICT_JDK_PREFIXES=( gcj )

# Find parameters to be passed to the command-line invocation of "find" when
# cleaning jar files from ${WORK}. Specify this to prevent cleaning of wanted,
# specific jar files: e.g.,
#     JAVA_CLEAN_JAR_FILES_PARAMS=( -not -wholename 'bootstrap/young_lad.jar' )
JAVA_CLEAN_JAR_FILES_PARAMS=( )

# Absolute or relative path under ${WORK} into which external jar files will
# be symlinked. Though this path is usually "lib" for most exheres, you must
# still explicitly specify it to have symlinking performed for you. Example:
#     JAVA_SRC_LIBRARY_DIR="lib"
JAVA_SRC_LIBRARY_DIR=""

# Array of absolute paths to or relative names of external jar files to be
# symlinked into ${JAVA_SRC_LIBRARY_DIR} during the "src_prepare" phase.
# External jar files should be buildtime dependencies of this exheres. An
# example mixing both absolute paths to and relative names of external files:
#     JAVA_SRC_PREPARE_JARS=( jarjar qdox "/usr/share/asm/asm.jar" )
#
# If filenames are not known until install time, leave this array blank and
# call "symlink_jars" within your "src_prepare" function.
JAVA_SRC_PREPARE_JARS=( )

# Array of absolute paths to or relative names of external jar files to be
# symlinked into ${JAVA_SRC_LIBRARY_DIR} during the "src_test" phase.
# External jar files should be test-time dependencies of this exheres. An
# example with slotted dependencies:
#     JAVA_SRC_TEST_JARS=( "junit:4" )
#
# If filenames are not known until install time, leave this array blank and
# call "symlink_jars" within your "src_test" function.
JAVA_SRC_TEST_JARS=( )

# Array of absolute paths to text files to be "deversion"-ated. Ant "build.xml"
# files often hardcode references to pre-bundled jar files with names suffixed
# by a version specifier. This is bad, as this exlib replaces all pre-bundled
# jar files with externally symlinked jar files with names NEVER EVER suffixed
# by a version specifier. To resolve the discrepancy, we could do one of two
# ugly hacks:
#
# * Sed affected "build.xml" files, removing jar filename version specifiers OR
# * Grep affected "build.xml" files for these version specifiers and, when
#   symlinking in external jar files, add the version specifier for each jar
#   filename to its symlink filename.
#
# The first is easier. And easier is better. So that's what we do. Example
# deversioning two files, "build.xml" and "common-build.xml":
#     JAVA_SRC_PREPARE_DEVERSION_FILES=( "${JAVA_BUILD_XML}" "common-build.xml" )
JAVA_SRC_PREPARE_DEVERSION_FILES=( )

# Absolute or relative path under "${WORK}" into which javadoc HTML files will
# be generated by the "${JAVA_BUILD_XML}" file for this exheres. Though this path
# is typically "javadoc" for most exheres, you must still specify this global to
# have installation of these files performed for you. Example:
#     JAVA_SRC_INSTALL_JAVADOC_DIR="javadoc"
JAVA_SRC_INSTALL_JAVADOC_DIR=""

# Array of absolute paths to this exheres' output jar files to be installed
# under "$(which_installed_jar_dir_for_this_exheres)", with suffixing versions
# automatically removed from filenames on your behalf. Example:
#     JAVA_SRC_PREPARE_INSTALL_JARS=( "dist/${PNV}.jar" )
#
# If filenames are not known until install time, leave this blank and explicitly
# call "install_jars" within your "src_install".
JAVA_SRC_INSTALL_JARS=( )

# ....................{ CONSTANTS                          }....................
# This exlib sets these constants on your behalf. Read them; don't write them.
# 
# Scratch that -- don't even read them. If you access these constants in any
# exheres, you're doing something wrong. :)

# Exheres name of the currently selected Java compiler.
JAVA_JDK=$(eclectic java-jdk show)

# Absolute path to the directory having JDK jar files for the above compiler:
# e.g., "rt.jar", "jce.jar".
JAVA_JRE_LIBRARY_DIR="/usr/$(get_libdir)/jre/lib/"

# Set, if disabling sydbox's network sandboxing. At the moment, this is only
# enabled when "gcj" is the currently selected Java compiler. This additionally
# implies that "gij" is the currently selected Java interpreter.
#
# See the "java_pkg_setup" function for detail.
JAVA_IS_DISABLING_NETWORK_SANDBOXING=

# Set, if recursively deleting all class files from "${WORK}" immediately after
# extracting source tarballs. Such class files are often bundled with tarballs
# to avoid the need for user recompilation. Make them suffer; oh, yes.
#
# Defaults to set.
JAVA_IS_CLEANING_CLASS_FILES=1

# Set, if recursively deleting all jar files from "${WORK}" immediately after
# extracting source tarballs. Such jar files are often bundled with tarballs
# to reduce dependency hell. For us, bundled jar files only aggravate hell.
#
# Defaults to set.
JAVA_IS_CLEANING_JAR_FILES=1

# Set, if calling "default_src_unpack" to perform automated unpacking of
# downloaded archives. Most exheres want this; those that do not (e.g., Eclipse,
# Eclipse SWT) require sufficiently complex unpacking to warrant their doing it
# themselves. (This is not recommended.)
#
# Defaults to unset.
JAVA_IS_UNPACKING_MANUALLY=

# Bash pattern matching the version suffix commonly appended to jar filenames.
# This pattern matches conventional versions (e.g., "hamcrest-1.2.jar") and
# unconventional revisioned versions (e.g., "jarjar-1.0rc8.jar"). By design,
# this pattern may also be passed without change to "egrep" or "sed -r".
#
# Don't forget to append a '$' if appropriate!
JAVA_JAR_VERSION_PATTERN='-[[:digit:].]+(rc[[:digit:].]+)?\.jar'

# Bash pattern matching the same from within a parameter expansion: e.g.,
#
#    Echoes "harhar.jar".
#    JAR_FILE=harhar-5.62.951.jar && \
#        echo ${JAR_FILE/${JAVA_JAR_PARAMETER_VERSION_PATTERN}/.jar}
JAVA_JAR_PARAMETER_VERSION_PATTERN='%-+([[:digit:].])*(rc+([[:digit:].]))\.jar'

# ....................{ PHASES                             }....................
javafix_pkg_setup() {
    default
    echo ">>> Setting up exheres defaults"

    # Die if the currently selected Java compiler is exheres restricted.
    if [[ -n "${JAVA_RESTRICT_JDK_PREFIXES[@]}" ]]; then
        local JAVA_RESTRICT_JDK_PREFIX
        for   JAVA_RESTRICT_JDK_PREFIX in "${JAVA_RESTRICT_JDK_PREFIXES}"; do
            if [[ "${JAVA_JDK}" = "${JAVA_RESTRICT_JDK_PREFIX}"* ]]; then
                eerror "Your currently selected Java compiler is \"${JAVA_JDK}\". Unfortunately, \"${PNV}\""
                eerror "reports it currently fails under this compiler. Consider installing and enabling"
                eerror "a better supported Java compiler: e.g., \"icedtea6\"."
                die_unless_nonfatal "${PNV} refuses to build under ${JAVA_JDK}"
            fi
        done
    fi

    # Warn if the currently selected Java compiler is GCJ.
    if [[ "${JAVA_JDK}" == gcj* ]]; then
        ewarn "Your currently selected Java compiler is \"gcj\". Unfortunately, this compiler"
        ewarn "violates sydbox network sandboxing by attempting to open spurious DNS requests."
        ewarn "Consider installing and enabling a better supported Java compiler: e.g., \"icedtea6\"."
        JAVA_IS_DISABLING_NETWORK_SANDBOXING=1
    fi
}

javafix_src_unpack() {
    # Call "default_src_unpack", unless the calling exheres has other plans.
    if [[ -z "${JAVA_IS_UNPACKING_MANUALLY}" ]]; then
        default
    fi

    # The "ant_src_unpack" function recursively destroys the contents of all
    # paths in "${ANT_BUNDLED_LIBSDIR}". Now, we must not destroy the "${WORK}"
    # path. However, some Java libraries (e.g., Hamcrest) come with jar files
    # pre-bundled in the "${WORK}" path. We thus homebrew this boolean to
    # recursively remove jar files rather than all files and paths, prior to
    # calling the "ant_src_unpack" function.
    if [[ "${JAVA_IS_CLEANING_JAR_FILES}" ]]; then
        echo ">>> Removing jar files"
        clean_jar_files
    fi

    if [[ "${JAVA_IS_CLEANING_CLASS_FILES}" ]]; then
        echo ">>> Removing class files"
        clean_class_files
    fi
}

javafix_src_prepare() {
    javafix_src_preamble
    default

    # Deversion files after patching files above but before invoking Ant below.
    if [[ -n "${JAVA_SRC_PREPARE_DEVERSION_FILES[@]}" ]]; then
        echo ">>> Removing jar filename version specifiers"
        deversion_java_files "${JAVA_SRC_PREPARE_DEVERSION_FILES[@]}"
    fi

    if [[ -n "${JAVA_SRC_PREPARE_JARS[@]}" ]]; then
       [[ -n "${JAVA_SRC_LIBRARY_DIR}" ]] ||
            die_unless_nonfatal "\$JAVA_SRC_LIBRARY_DIR not set; cannot link external jar files"

        # Clean the library directory of all jar files regardless of whether 
        # ${JAVA_IS_CLEANING_JAR_FILES} is disabled or not. These jar files
        # should be replaced by symlinks in the call to "symlink_jars".
        if [[ -d "${JAVA_SRC_LIBRARY_DIR}" ]]; then
            echo ">>> Culling library directory"
            edo rm -f "${JAVA_SRC_LIBRARY_DIR}"/*.jar
        fi

        echo ">>> Linking library jar files"
        symlink_jars "${JAVA_SRC_LIBRARY_DIR}" \
                     "${JAVA_SRC_PREPARE_JARS[@]}"
    fi
}

javafix_src_configure() {
    javafix_src_preamble
}

javafix_src_compile() {
    javafix_src_preamble
}

javafix_src_test() {
    javafix_src_preamble

    if [[ -n "${JAVA_SRC_TEST_JARS[@]}" ]]; then
       [[ -n "${JAVA_SRC_LIBRARY_DIR}" ]] ||
            die_unless_nonfatal "\$JAVA_SRC_LIBRARY_DIR not set; cannot link external jar files"
        echo ">>> Linking test jar files"
        symlink_jars "${JAVA_SRC_LIBRARY_DIR}" \
                     "${JAVA_SRC_TEST_JARS[@]}"
    fi
}

javafix_src_install() {
    javafix_src_preamble

    echo ">>> Installing documents"
    emagicdocs

    if [[ -n "${JAVA_SRC_INSTALL_JAVADOC_DIR}" ]]; then
        echo ">>> Installing javadoc"
        docinto "html/javadoc"
        dodoc "${JAVA_SRC_INSTALL_JAVADOC_DIR}"/*
    fi

    if [[ -n "${JAVA_SRC_INSTALL_JARS[@]}" ]]; then
        echo ">>> Installing jar files"
        install_jars "${JAVA_SRC_INSTALL_JARS[@]}"
    fi
}

javafix_src_preamble() {
    if [[ -n "${JAVA_IS_DISABLING_NETWORK_SANDBOXING}" ]]; then
        ewarn "Disabling network sandboxing..."
        sydboxcmd 'sandunbox/net'
    fi
}

# ....................{ SETTERS                            }....................
# void disable_class_file_cleaning(void)
#
# Disable recursive deletion of all class files under ${WORK} in "src_unpack".
# Calling this function is preferable to explicitly unsetting the global.
disable_class_file_cleaning() {
    unset JAVA_IS_CLEANING_CLASS_FILES
}

# void disable_jar_file_cleaning(void)
#
# Disable recursive deletion of all jar files under ${WORK} in "src_unpack".
# Calling this function is preferable to explicitly unsetting the global.
disable_jar_file_cleaning() {
    unset JAVA_IS_CLEANING_JAR_FILES
}

# void enable_manual_java_unpacking(void)
#
# Prevent calling the "default_src_unpack" function in the "src_unpack" phase.
# Calling this function is preferable to explicitly setting the global.
enable_manual_java_unpacking() {
    JAVA_IS_UNPACKING_MANUALLY=1
}

# ....................{ CLEANERS                           }....................
# void clean_jar_files(void)
#
# Recursively remove all jar files under ${WORK}. (Fairly destructive!)
clean_jar_files() {
    # Do not use "edo rm -f "${WORK}"/**/*.jar" as that tends to glob more
    # files than can be reasonably handled by the shell.
    edo find "${WORK}" -type f -iname '*.jar' \
        "${JAVA_CLEAN_JAR_FILES_PARAMS[@]}" -delete
}

# void clean_class_files(void)
#
# Recursively remove all class files under ${WORK}. (Danger, Exherbon.)
clean_class_files() {
    edo find "${WORK}" -type f -iname '*.class' -delete
}

# ....................{ DEVERSIONERS                       }....................
# void deversion_java_files(char *filename1, char *filename2, ...)
#
# Patch the passed absolute or relative filenames of jar file version suffixes.
# These files are typically "build.xml" files, so as to generalize their build
# process to non-versioned jar files installed on the local machine.
deversion_java_files() {
    local EPN
    local DEVERSION_JAVA_FILE
    for   DEVERSION_JAVA_FILE in ${*}; do
        # Implicitly remove filename version specifiers matching:
        # "-${DSTAMP}.jar", "-${TSTAMP}.jar", or "-${TODAY}.jar". These
        # are Ant properties generated by the "tstamp" task and, when
        # used in jar filenames, mostly produce badly named jar files.
        #
        # This should be safe... should.
        edo sed -i "${DEVERSION_JAVA_FILE}" \
            -r -e 's~-\$\{(DSTAMP|TSTAMP|TODAY)\}\.jar~.jar~'

        # Explicitly remove filename version specifiers only for externally
        # symlinked jar files, where the 'E' in "EPN" stands for external.
        #
        # Do not remove version specifiers from other jar filenames as those
        # filenames may not actually exist. As we can't be sure, we don't.
        if [[ -n "${JAVA_SRC_PREPARE_JARS[@]}" ]]; then
            for EPN in "${JAVA_SRC_PREPARE_JARS[@]}"; do
                if [[ "${EPN:0:1}" != / ]]; then  # ignore absolute paths
                    edo sed -i "${DEVERSION_JAVA_FILE}" \
                        -r -e "s~${EPN}${JAVA_JAR_VERSION_PATTERN}~${EPN}.jar~"
                fi
            done
        fi
    done
}

# ....................{ SYMLINKERS                         }....................
# void symlink_jars(char *symlink_dir, char *jar_spec1, char *jar_spec2, ...)
#
# Symlink the passed jar specificiers to relative filenames having the same
# basename in the passed absolute or relative path under ${WORK} to the symlink
# directory. If the path already exists, this function kills all jar files that
# may still exist in it; if it does not, this function creates it. Killing jars
# may be necessary for exheres disabling jar file cleaning and, in any case,
# never hurts. (They are external dependencies, after all.)
#
# "Jar specificiers" are compact strings uniquely identifying external jar
# files already installed to the current system by one or more exheres on which
# this exheres depends. In their simplest form, jar specifiers are merely paths:
#
# * If an absolute path, the path is symlinked as is without modification.
# * If a string having no whitespace, this string signifies both the exheres
#   name (and optional slot) and jar filename. The slot, if present, is
#   demarcated via a colon. (See below.) Then, the absolute path
#   "/usr/share/${exheres_name}/${slot}" is prepended to the string, the type
#   ".jar" is appended to the string, and the final path is symlinked. Example:
#
#    # Symbolically links "/usr/share/ecocide/ecocide.jar" into "lib/".
#    symlink_jars("lib" "ecocide")
#
#    # Symbolically links "/usr/share/ecocide/4/ecocide.jar" into "lib/".
#    symlink_jars("lib" "ecocide:4")
#
#   If the resultant absolute path is not found, this also tries
#   "/usr/share/$(basename ${jar_spec%%-*})/". This is the first part of the
#   passed jar specifier up to but not including the first hyphen. Example:
#
#    # Tries "/usr/share/moa-core/moa-core.jar", which is not found. Then
#    # tries "/usr/share/moa/moa-core.jar", which is found. Finally,
#    # symbolically links "/usr/share/moa/moa-core.jar" into "lib/".
#    symlink_jars("lib" "moa-core")
# * If a string having whitespace, the string is first split on the first
#   whitespace in that string. The first half of the string signifies the
#   exheres name (and optional slot), while the second half signifies the
#   jar filename as above. The slot, if present, is demarcated from the
#   exheres name via a colon. (See below.) Then, the absolute path
#   "/usr/share/${exheres_name}/${slot}" is prepended to the string, the type
#   ".jar" is appended to the string, and the final path is symlinked. Example:
#
#    # Symbolically links "/usr/share/ecocide/1080.jar" into "lib/".
#    symlink_jars("lib" "ecocide" "1080")
#
#    # Symbolically links "/usr/share/ecocide/1.2/1080.jar" into "lib/".
#    symlink_jars("lib" "ecocide:1.2" "1080")
#
# This function is usually clever enough to suss out the absolute path to
# whatever you pass it. When it doesn't, simply pass the absolute path.
symlink_jars() {
    illegal_in_global_scope
    [[ ${#} -ge 2 ]] || die_unless_nonfatal "at least two arguments needed"

    local SYMLINK_DIR="${1}"
    [[ -d "${SYMLINK_DIR}" ]] || edo install -d "${SYMLINK_DIR}"

    shift
    local JAR_SPEC EXHERES_NAME JAR_FILENAME
    for   JAR_SPEC in ${*}; do
        # If an absolute path, use as is.
        if [[ "${JAR_SPEC:0:1}" = / ]]; then
            INSTALLED_JAR_FILE="${JAR_SPEC}"
        # Otherwise, get the absolute path.
        else
            # If split on whitespace, grep the exheres name from jar filename in
            # the passed jar specifier via Bash regexp matching.
            if [[ "${JAR_SPEC}" =~ ^([^[:space:]]+)[[:space:]]+(.+)$ ]]; then
                INSTALLED_JAR_FILE=$(which_installed_jar_file_nonfatal "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")
            # Otherwise, the jar filename is the passed jar specifier.
            else
                INSTALLED_JAR_FILE=$(which_installed_jar_file_nonfatal "${JAR_SPEC}" "${JAR_SPEC}")

                # If not found but has a hyphen, grep the exheres name again.
                if [[ ! -f "${INSTALLED_JAR_FILE}" ]] &&
                   [[ "${JAR_SPEC}" =~ ^([^-]+)- ]]; then
                   INSTALLED_JAR_FILE=$(which_installed_jar_file_nonfatal "${BASH_REMATCH[1]}" "${JAR_SPEC}")
                fi
            fi
        fi

        [[ -f "${INSTALLED_JAR_FILE}" ]] ||
            die_unless_nonfatal "${INSTALLED_JAR_FILE} not found"
        edo ln -s "${INSTALLED_JAR_FILE}" "${SYMLINK_DIR}"/
    done
}

# ....................{ INSTALLERS                         }....................
# The following convenience functions install all Java libraries produced by
# this exheres into local directories appropriate for this exheres.

# void install_jars(char *filename1, char *filename2, ...)
#
# Copy absolute filenames to relative filenames having the same basename sans
# version under the above directory. By "sans version", we mean basename minus
# "-${PV}". Jar filenames should be versionless so as to permit their usage
# elsewhere without concern for the specific versions they represent. This
# resembles:
#
#   cp "$filename1" "$filename2" ... "${IMAGE}/${JAVA_SRC_INSTALL_JARS_IMAGE_DIR}"
install_jars() {
    illegal_in_global_scope
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"

    insinto $(which_installed_jar_dir_for_this_exheres)

    local INSTALL_JAR_FILE
    for   INSTALL_JAR_FILE in ${*}; do
        # Strip versions from filenames: e.g., convert "zebrapig-0.42.jar" to
        # "zebrapig.jar". The pattern substitution requires the bash "extglob"
        # shell option be enabled, which it is under exheres-0.
        #
        # See "man bash" for details.
        newins "${INSTALL_JAR_FILE}" \
            $(basename "${INSTALL_JAR_FILE/${JAVA_JAR_PARAMETER_VERSION_PATTERN}/.jar}")
    done
}

# void install_jar_as(char *filename1, char *filename2)
#
# Copy absolute "$filename1" to relative "$filename2" under the above directory.
# This is functionally equivalent to:
#
#   cp "$filename1" "${IMAGE}/$install_jar_dir/$filename2"
install_jar_as() {
    illegal_in_global_scope
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "exactly two arguments needed"

    local JAR_FILE_SOURCE="${1}"
    local JAR_FILE_TARGET="${2}"

    # Ignore absolute paths and version specifiers in target jar filenames.
    if [[ ${JAR_FILE_TARGET:0:1} = / ]]; then
        JAR_FILE_TARGET="${JAR_FILE_TARGET##*/}"
    fi
    if [[ "${JAR_FILE_TARGET}" =~ ^(.+)${JAVA_JAR_VERSION_PATTERN}$ ]]; then
        JAR_FILE_TARGET="${BASH_REMATCH[1]}"
    fi

    echo "installing ${JAR_FILE_SOURCE} to $(which_installed_jar_dir_for_this_exheres)/${JAR_FILE_TARGET}"
    insinto $(which_installed_jar_dir_for_this_exheres)
    newins "${JAR_FILE_SOURCE}" "${JAR_FILE_TARGET}"
}

# ....................{ LOCATERS                           }....................
# char *which_installed_jar_dir(char *exheres_name)
#
# Given a passed exheres name (with optional slot appended to that name),
# returns the absolute path to the directory into which jar files were earlier
# installed for that exheres: e.g.,
#
#     # Echoes "/usr/share/turkish_dream".
#     echo $(which_installed_jar_dir "turkish_dream")
#     # Echoes "/usr/share/british_moors/2.5".
#     echo $(which_installed_jar_dir "british_moors:2.5")
#
# Append the exheres slot to the exheres name as in "DEPENDENCIES": e.g.,
# "${PN}:${SLOT}". A slot need not be specified, of course.
#
# For safety, this function dies when the path does not exist.
which_installed_jar_dir() {
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "one argument needed"

    local    INSTALLED_JAR_DIR=$(which_installed_jar_dir_nonfatal ${*})
    [[ -d "${INSTALLED_JAR_DIR}" ]] ||
        die_unless_nonfatal "${INSTALLED_JAR_DIR} not found"
    echo  "${INSTALLED_JAR_DIR}"
}

# char *which_installed_jar_dir_for_this_exheres(void)
#
# Returns the absolute path to the directory into which jar files will be
# installed for the current exheres:
#
#     # Echoes "/usr/share/clathrate_gun/1" assuming this exheres is named
#     # "clathrate_gun" and slotted with 1.
#     echo $(which_installed_jar_dir_for_this_exheres)
#
# This function does not die when the path does not exist, since this function
# is usually called from the "src_install" phase prior to creation of the path.
which_installed_jar_dir_for_this_exheres() {
    [[ ${#} -eq 0 ]] || die_unless_nonfatal "no arguments needed"
    which_installed_jar_dir_nonfatal $(get_java_exheres_name_for_this_exheres)
}

# char *which_installed_jar_dir_nonfatal(char *exheres_name)
#
# Like "which_installed_jar_dir" but does not die when the path does not exist.
# Avoid calling this function; it is unsafe, and intended only as a utility.
which_installed_jar_dir_nonfatal() {
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "one arguments needed"

    # Install jar files to possibly slotted subdirectories under "/usr/share".
    # Exheres matching this Bash regex are slotted exheres.
    if [[ "${1}" =~ ^(.+):([^:]+)$ ]]
    then echo "/usr/share/${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
    else echo "/usr/share/${1}"
    fi
}

# char *which_installed_jar_file(char *jar_file)
# --OR--
# char *which_installed_jar_file(char *exheres_name, char *jar_file)
#
# Given a jar file and optional exheres name and slot, returns the absolute path
# to that jar file as installed on the local system: e.g.,
#
#     # Echoes "/usr/share/hamcrest/hamcrest-library.jar".
#     echo $(which_installed_jar_file "hamcrest-library")
#     # Echoes "/usr/share/raki-saki/raki-saki-core.jar".
#     echo $(which_installed_jar_file "dist/lib/raki-saki-core.5.22.jar")
#     # Echoes "/usr/share/raki-saki/org.turkish.dream.jar".
#     echo $(which_installed_jar_file "raki-saki" "bin/org.turkish.dream-0.1.3.jar")
#     # Echoes "/usr/share/raki-saki/8/org.turkish.dream.jar".
#     echo $(which_installed_jar_file "raki-saki:8" "bin/org.turkish.dream-0.1.3.jar")
#
# Append the exheres slot to the exheres name as in "DEPENDENCIES": e.g.,
# "${PN}:${SLOT}". A slot need not be specified, of course. See examples.
#
# This automatically strips version strings from passed jar filenames as well as
# establishing the expected parent directory. As above, for safety, this
# function dies when the file does not exist.
which_installed_jar_file() {
    local    INSTALLED_JAR_FILE=$(which_installed_jar_file_nonfatal ${*})
    [[ -f "${INSTALLED_JAR_FILE}" ]] ||
        die_unless_nonfatal "${INSTALLED_JAR_FILE} not found"
    echo  "${INSTALLED_JAR_FILE}"
}

# char *which_installed_jar_file_for_this_exheres(void)
#
# Returns the absolute path to the jar file to be installed for the current
# exheres: e.g.,
#
#     # Echoes "/usr/share/clathrate_gun/1/clathrate_gun.jar" assuming this
#     # exheres is named "clathrate_gun" and slotted with 1.
#     echo $(which_installed_jar_file_for_this_exheres)
#
# This function should only be called from exheres installing a jar file having
# the same name as the exheres name. (Coveniently, this is most of them.)
#
# This function does not die when the file does not exist, since this function
# is usually called from the "src_install" phase prior to creation of the file.
which_installed_jar_file_for_this_exheres() {
    [[ ${#} -eq 0 ]] || die_unless_nonfatal "no arguments needed"
    which_installed_jar_file_nonfatal $(get_java_exheres_name_for_this_exheres)
}

# char *which_installed_jar_file_nonfatal(char *jar_file)
# --OR--
# char *which_installed_jar_file_nonfatal(char *exheres_name, char *jar_file)
#
# Like "which_installed_jar_file" but does not die when the file does not exist.
# Avoid calling this function; it is unsafe, and intended only as a utility.
which_installed_jar_file_nonfatal() {
    [[ ${#} -eq 1 ]] ||
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "one or two arguments needed"
    [[ -n "${1}"  ]] || die_unless_nonfatal "non-null argument needed"

    local JAR_FILENAME EXHERES_NAME

    if   [[ ${#} -eq 1 ]]
    then JAR_FILENAME="${1}"
    else JAR_FILENAME="${2}"; EXHERES_NAME="${1}"
    fi

    local JAR_BASENAME="${JAR_FILENAME##*/}"   # filename sans path
    local JAR_ROOTNAME="${JAR_BASENAME%.jar}"  # filename sans path and type

    if [[ -z "${EXHERES_NAME}" ]]
    then EXHERES_NAME="${JAR_ROOTNAME}"
    fi

    # ${JAR_ROOTNAME} could still contain a ':'-suffixed slot number. (Cut that.)
    local JAR_TRUENAME="${JAR_ROOTNAME%:*}"    # filename sans path, type, slot
    echo $(which_installed_jar_dir_nonfatal "${EXHERES_NAME}")"/${JAR_TRUENAME}.jar"
}

# char *get_java_exheres_name_for_this_exheres(void)
#
# Return this exheres name optionally suffixed by this exheres slot, if given.
# This is a utility function called by the "*_for_this_exheres" functions above.
get_java_exheres_name_for_this_exheres() {
    # Exheres having no slot or a zero slot are unslotted exheres.
    if [[ -z "${SLOT}" ]] || [[ "${SLOT}" -eq 0 ]]
    then echo "${PN}"
    else echo "${PN}:${SLOT}"
    fi
}
