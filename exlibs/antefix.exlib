# Copyright 2010 Cecil Curry <leycec@gmail.com>
# Distributed under the terms of the GNU General Public License v2
#
# --------------------( SYNOPSIS                           )--------------------
# This exlib improves "ant.exlib" with handling for command-line properties,
# external dependencies, and jar and javadoc installation. These improvements
# should be backported into "ant.exlib" where deemed appropriate.
#
# This exlib is thus backwards compatible with other exlibs and exheres
# requiring "ant.exlib".
#
# --------------------( ETYMOLOGY                          )--------------------
# Technically, an antefix is "an ornament of the cymatium of a classic cornice,
# sometimes pierced for the escape of water." In reality, I'm not sure I know
# what a cymatium is. Or a cornice.

# ....................{ EXHERES                            }....................
# All Ant exheres are, by assumption, Java exheres. It is absolutely critical
# this exlib explicitly requires the "javafix" exlib, for both this reason and
# the possibility of subtle bugs were this exlib to not require that exlib. In
# particular, note that the following two require statements are not equal:
#
#     # This overwrites all "antefix" exlib phases with "javafix" exlib phases,
#     # which is never what you want.
#     require antefix javafix
#
#     # This overwrites all "javafix" exlib phases with "antefix" exlib phases,
#     # which is always what you want.
#     require javafix antefix
#
# This exlib explicitly requires the "javafix" exlib so as to eliminate such
# subtle bugs. This has the unfortunate effect, however, of preventing the
# passing of parameters from exheres to the "javafix" exlib. Affected exheres 
# should work around this by calling setter functions for the desired parameters
# in global scope after requiring this exlib. Example:
#
#     # Instead of this...
#     require antefix javafix [ clean_jar_files=false ]
#
#     # ...your exheres should do this.
#     require antefix
#     disable_jar_file_cleaning
require javafix
export_exlib_phases src_unpack src_prepare src_compile src_test src_install

# ....................{ CONFIGURATION                      }....................
# Absolute or relative path under ${WORK} to the "build.xml" for this exheres.
ANT_BUILD_XML="build.xml"

# Ant parameters to be passed to all command-line invocations of Ant. Example:
#     ANT_PARAMS=( -Dproject.classpath=/usr/share/zebrapig/ )
ANT_PARAMS=( )

# Ant tasks to be run against ${ANT_BUILD_XML} during the "src_prepare" phase.
# This is empty by default, implying no Ant tasks will be run for preparation.
# Example:
#     ANT_SRC_PREPARE_PARAMS=( init )
#
# This and all other Ant task arrays below are empty by default, as Ant is by
# design unable to force task names to adhere to ISO standards. In other words,
# any "build.xml" file can name its tasks anything; and they often due. Since
# there's no sensible way of predicting this, or programmatically safe way of
# extracting this from exheres-specific "build.xml" files, Ant exheres must
# manually specify these tasks.
ANT_SRC_PREPARE_PARAMS=( )

# Ant tasks to be run against ${ANT_BUILD_XML} during the "src_compile" phase.
# This is empty by default, implying no Ant tasks will be run for compilation.
# Example:
#     ANT_SRC_COMPILE_PARAMS=( compile )
ANT_SRC_COMPILE_PARAMS=( )

# Ant tasks to be run against ${ANT_BUILD_XML} during the "src_test" phase.
# This is empty by default, implying no Ant tasks will be run for testing.
# Example:
#     ANT_SRC_TEST_PARAMS=( test )
ANT_SRC_TEST_PARAMS=( )

# Ant tasks to be run against ${ANT_BUILD_XML} during the "src_install" phase.
# This is empty by default, implying no Ant tasks will be run for installation.
# Example:
#     ANT_SRC_INSTALL_PARAMS=( jar )
ANT_SRC_INSTALL_PARAMS=( )

# If true, programmatically create a new "${WORK}/build.xml" file for this
# exheres. (Enable this for exheres providing no "build.xml", but for which the
# default "build.xml" is sufficient to build the project. Most modern Java
# projects already provide Ant, Maven, or Ivy build files; so, this should be
# used sparingly.)
#
# Defaults to false. To set this variable, do not set it directly. Instead, call
# the "enable_build_xml_creation" function to have it set for you. Do this at
# the earliest time possible after requiring this exlib. Example:
#
#      # "qdox-1.11.exheres-0" requires "build.xml" creation. Make it so.
#      require antefix
#      enable_build_xml_creation
ANT_IS_CREATING_BUILD_XML=

# ....................{ CONSTANTS                          }....................
# Absolute path to the "ant" binary. ${ANT_HOME} is an environment variable set
# by "/etc/env.d/*ant", itself installed by the Ant exheres. It usually points
# to "/usr/share/ant/".
ANT="${ANT_HOME}/bin/ant"

# ....................{ EXHERES                            }....................
DEPENDENCIES+="
    build:
        dev-java/apache-ant
"

# ....................{ PHASES                             }....................
antefix_src_unpack() {
    javafix_src_unpack

    if [[ "${ANT_IS_CREATING_BUILD_XML}" ]]; then
        einfo "Creating ${ANT_BUILD_XML}..."
        create_build_xml
    fi

    # Kill evil bundled jar files!
    #
    # This is a deprecated code block, and now (more or less) considered bad.
    # The "java_src_unpack" cleans all embedded jar files if and only if the
    # "clean_jar_files" exparam is true. This code block remains, however, until
    # we verify that no exheres requires this code block.
    if [[ -n "${ANT_BUNDLED_LIBSDIR[@]}" ]]; then
        for ANT_BUNDLED_LIBS in "${ANT_BUNDLED_LIBSDIR[@]}"; do
            if [[ -d "${WORK}/${ANT_BUNDLED_LIBS}" ]]; then
                edo rm -rf "${WORK}/${ANT_BUNDLED_LIBS}"/*
            fi
        done
    fi
}

antefix_src_prepare() {
    # Patch build files prior to invoking Ant.
    javafix_src_prepare

    # Do not invoke Ant here! The reasons are subtle. The calling exheres must
    # have the opportunity to patch files in its "src_prepare" function prior
    # to invoking Ant. Hypothetically, if this function invoked Ant, that
    # exheres would need to delay calling this function until after it had
    # already patched files: e.g., something like
    #
    #     # This is subtly bad.
    #     exheres_src_prepare() {
    #         edo sed -e 's~bad~good~' -i "${ANT_BUILD_XML}"
    #         antefix_src_prepare
    #     }
    #
    # But the "antefix_src_prepare" function calls the "javafix_src_prepare"
    # function that calls "expatch" to patch files. But "expatch" should be
    # called //before// performing any such sedding, as "expatch" tends to
    # overwrite file changes with patched content. So we can't reliably do the
    # above. Instead, we need to partition file patching and Ant invocation
    # into two phases. There is no "src_patch" stage and probably never will be.
    # Thus, we need to push Ant invocation into a later stage that does exist:
    # and "src_compile" is the best candidate. Then the above example becomes:
    #
    #     # This is better!
    #     exheres_src_prepare() {
    #         antefix_src_prepare
    #         edo sed -e 's~bad~good~' -i "${ANT_BUILD_XML}"
    #     }
    #
    # It's not pretty, but it works reliably.
}

antefix_src_compile() {
    javafix_src_compile

    # Never invoke Ant unless you have a task with which to invoke it, since
    # "build.xml" files often supply a default task performing all relevant
    # tasks when passed no explicit task. (This is rarely what we want.)
    if [[ -n "${ANT_SRC_PREPARE_PARAMS[@]}" ]]; then
        einfo "Preparing source files..."
        eant "${ANT_BUILD_XML}" ${ANT_PARAMS[@]} ${ANT_SRC_PREPARE_PARAMS[@]}
    fi

    if [[ -n "${ANT_SRC_COMPILE_PARAMS[@]}" ]]; then
        einfo "Compiling source files..."
        eant "${ANT_BUILD_XML}" ${ANT_PARAMS[@]} ${ANT_SRC_COMPILE_PARAMS[@]}
    fi
}

antefix_src_test() {
    javafix_src_test

    if [[ -n "${ANT_SRC_TEST_PARAMS[@]}" ]]; then
        einfo "Testing compiled files..."
        eant "${ANT_BUILD_XML}" ${ANT_PARAMS[@]} ${ANT_SRC_TEST_PARAMS[@]}
    fi
}

antefix_src_install() {
    # Invoke Ant, which probably generates jar files, prior to calling the
    # parent "src_install" function, which actually install these files.
    if [[ -n "${ANT_SRC_INSTALL_PARAMS[@]}" ]]; then
        einfo "Collecting jar files..."
        eant "${ANT_BUILD_XML}" ${ANT_PARAMS[@]} ${ANT_SRC_INSTALL_PARAMS[@]}
    fi

    javafix_src_install
}

# ....................{ EANT                               }....................
# void eant(char *build_xml_filename, char *param1, char *param2, ...)
#
# Call "ant" with the passed absolute or relative path to a "build.xml" file and
# zero or more command-line parameters to be passed to this "build.xml" file.
# These parameters must be either: {a} Ant properties of the form "-Dkey=value"
# (e.g., "-Djavacc.home=lib/javacc.jar") or {b} Ant tasks of the form "task"
# (e.g., "compile").
#
# This function supplants the earlier "_ant_run" function and, unlike that
# function, may be explicitly called by exheres operating on multiple
# "build.xml" files. (Exheres not operating on multiple "build.xml" files should
# avoid calling this function explicitly.)
eant() {
    illegal_in_global_scope
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"

    local EANT_BUILD_XML="${1}"
    shift

    # Always enable the "noget" property when invoking Ant. This instructs Ant
    # to ignore any "get" tasks defined by this "build.xml" file; such tasks,
    # if defined, attempt to remotely download external jar files.
    edo "${ANT}" -f "${EANT_BUILD_XML}" -Dnoget=true "${@}"
}

# ....................{ BUILD.XML                          }....................
# void enable_build_xml_creation(void)
#
# Enables "build.xml" creation. This function should only be called in global
# exheres scope, as it provides exheres globals, Ant tasks, et al.
enable_build_xml_creation() {
    # Ensure the appropriate global boolean is also enabled.
    ANT_IS_CREATING_BUILD_XML=1

    # The created "build.xml" is guaranteed to support these options.
    MYOPTIONS+="debug doc"

    # Absolute or relative path under "${WORK}" from which sources files (e.g.,
    # .java files) will be read during compilation. You'll probably need to
    # manually move source files from wherever the archive unpacks them into
    # this directory -- unless you set ${ANT_SRC_COMPILE_SOURCE_NAMESPACE_DIR},
    # in which case this is done for you.
    ANT_SRC_COMPILE_SOURCE_DIR="src"

    # Absolute or relative path under "${WORK}" serving as the root of the Java
    # source file namespace for this exheres. Most Java projects having no
    # "build.xml" file have their namespace under "com"; thus, this will
    # probably be "com" for most exheres. For example, the JZlib project claims
    # the "com.jcraft.jzlib" namespace, and distributes a source tarball having
    # the "com/jcraft/jzlib/" directory; to appease Ant, the root of this
    # directory (e.g., "com") must be moved into a canonical directory that Ant
    # expects (e.g., "src"). So, this exheres sets:
    #     ANT_SRC_COMPILE_SOURCE_NAMESPACE_DIR="com"
    #
    # When set, this exlib automatically moves this directory under
    # ${ANT_SRC_COMPILE_SOURCE_DIR} as, again, this is what Ant expects.
    ANT_SRC_COMPILE_SOURCE_NAMESPACE_DIR=""

    # Absolute or relative path under "${WORK}" to which the output jar file
    # (NOTE: singular "jar file") will be created. Avoid changing this. If you
    # need to, you're probably better off writing your own "build.xml".
    ANT_SRC_INSTALL_JARS_DIR="dist"

    ANT_SRC_PREPARE_PARAMS=( )
    ANT_SRC_COMPILE_PARAMS=( compile )

    # Note: the "javadoc" task will be conditionally appended to this array,
    # later, if and only if the caller has enabled the exheres "doc" option.
    ANT_SRC_INSTALL_PARAMS=( jar )

    JAVA_SRC_PREPARE_SYMLINK_DIR="lib"
    JAVA_SRC_INSTALL_JARS=( "${ANT_SRC_INSTALL_JARS_DIR}/${PN}.jar" )
}

# void create_build_xml(char *filename)
#
# Create a new "build.xml" file appropriate for building this exheres. See
# "create_build_xml_file" for details as to the contents of this file.
create_build_xml() {
    illegal_in_global_scope
    [[ ${#} -eq 0 ]] || die_unless_nonfatal "no arguments needed"

    edo pushd "${WORK}"

    # Ensure this exheres doesn't already have a default "build.xml" file.
    [[ -f "${ANT_BUILD_XML}" ]] &&
        die_unless_nonfatal "${PN} already provides a default ${ANT_BUILD_XML}"

    create_build_xml_file "${ANT_BUILD_XML}"

    # Copy the source tree unpacked from the exheres tarball into the
    # canonical "${WORK}/src/" directory Ant expects.
    if [[ ! -d "${ANT_SRC_COMPILE_SOURCE_DIR}" ]]; then
        einfo "Creating source tree..."
        edo mkdir -p "${ANT_SRC_COMPILE_SOURCE_DIR}"
        if [[ -n "${ANT_SRC_COMPILE_SOURCE_NAMESPACE_DIR}" ]]; then
            edo mv "${ANT_SRC_COMPILE_SOURCE_NAMESPACE_DIR}" "${ANT_SRC_COMPILE_SOURCE_DIR}/"
        fi
    fi

    # Also ensure we generate javadoc if that option is enabled.
    if [[ -n "${JAVA_IS_INSTALLING_JAVADOC}" ]]; then
        JAVA_SRC_INSTALL_JAVADOC_DIR="javadoc"
        JAVA_SRC_INSTALL_PARAMS+=( javadoc )
    fi

    # Pop goes the Edo jidai.
    edo popd
}

# void create_build_xml(char *filename)
#
# Create a new "build.xml" file at the passed absolute or relative path
# appropriate for building this exheres. This is only appropriate for those
# exheres not already providing a "build.xml" file. By convention, this file
# defines the following top-level Ant tasks:
#
# * "compile", compiling class files for this exheres from "src/" to "build/".
# * "jar", jaring this exheres into "dist/".
# * "javadoc", generating HTML files for this exheres in "javadoc/".
#
# These tasks accept the following Ant properties at the command-line:
#
# * "src", an absolute or relative path to the root of the source directory.
#   Defaults to "${WORK}/src/". (You will probably have to either manually move
#   the source directory for this exheres to this default or redefine this
#   property. Either are fine.)
# * "lib", an absolute or relative path to the root of the input jar file
#   directory (i.e., the directory having symlinks to external dependencies).
#   Defaults to "${WORK}/lib/". (This exlib ensures that these dependencies will
#   be symlinked into this directory, when specified via the
#   ${ANT_SRC_PREPARE_SYMLINK_DIR} global.)
# * "build", an absolute or relative path to the root of the classes directory.
#   Defaults to "${WORK}/build/".
# * "dist", an absolute or relative path to the root of the output jar file
#   directory. Defaults to "${WORK}/build/".
# * "javadoc", an absolute or relative path to the root of the output javadoc
#   directory. Defaults to "${WORK}/javadoc/".
# * "debug", a "true" or "false" boolean that, if true, embeds debugging
#   metadata in compiled class files. Defaults to "false".
#
# Thus, exheres need to ensure source files appear in the directory
# corresponding to the "src" property, which defaults to "${WORK}/src/". But
# that's it. This exlib takes care of everything else for you. See
# implementation for details.
#
# This is a utility function only ever called by "create_build_xml".
create_build_xml_file() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "exactly one argument needed"

    local BUILD_XML_SRC_DIR="${ANT_SRC_COMPILE_SOURCE_DIR:-src}"
    local BUILD_XML_LIB_DIR="${ANT_SRC_PREPARE_SYMLINK_DIR:-lib}"
    local BUILD_XML_DIST_DIR="${ANT_SRC_INSTALL_JARS_DIR:-dist}"
    local BUILD_XML_JAR_FILE="${ANT_SRC_INSTALL_JARS[1]:-${BUILD_XML_DIST_DIR}/${PN}.jar}"
    local BUILD_XML_JAVADOC_DIR="${ANT_SRC_INSTALL_JAVADOC_DIR:-javadoc}"

    local BUILD_XML_DEBUG="false"
    if has debug ${MYOPTIONS}; then
        BUILD_XML_DEBUG=$(option debug && echo true || echo false)
    fi

    cat <<EOF > "${1}" 
<?xml version="1.0" encoding="utf-8"?>
<project name="${PN}" default="jar" basedir=".">
    <property name="src"     location="${BUILD_XML_SRC_DIR}"/>
    <property name="lib"     location="${BUILD_XML_LIB_DIR}"/>
    <property name="build"   location="build"/>
    <property name="dist"    location="${BUILD_XML_DIST_DIR}"/>
    <property name="javadoc" location="${BUILD_XML_JAVADOC_DIR}"/>
    <property name="jar"     value="${BUILD_XML_JAR_FILE}"/>
    <property name="debug"   value="${BUILD_XML_DEBUG}"/>

    <path id="lib.classpath">
        <fileset dir="\${lib}">
            <include name="**/*.jar"/>
        </fileset>
    </path>

    <target name="init">
        <tstamp/>
        <mkdir dir="\${lib}"/>
        <mkdir dir="\${build}"/>
        <mkdir dir="\${dist}"/>
        <mkdir dir="\${javadoc}"/>
    </target>

    <target name="compile" depends="init">
        <javac srcdir="\${src}" destdir="\${build}" debug="\${debug}"
               classpathref="lib.classpath"/>
    </target>

    <target name="jar" depends="compile">
        <jar jarfile="\${jar}" basedir="\${build}"/>
    </target>

    <target name="javadoc" depends="init">
        <javadoc sourcepath="\${src}" destdir="\${javadoc}"
                 classpathref="lib.classpath">
            <packageset dir="\${src}"/>
        </javadoc>
    </target>
</project>
EOF
}

