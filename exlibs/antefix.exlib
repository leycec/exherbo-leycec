# Copyright 2010 Cecil Curry <leycec@gmail.com>
# Distributed under the terms of the GNU General Public License v2
#
# --------------------( SYNOPSIS                           )--------------------
# This exlib improves "ant.exlib" with handling for command-line properties,
# external dependencies, and jar and javadoc installation. These improvements
# should be backported into "ant.exlib" where deemed appropriate.
#
# This exlib requires "ant.exlib", and is thus backwards compatible with other
# exlibs and exheres requiring "ant.exlib".
#
# --------------------( ETYMOLOGY                          )--------------------
# Technically, an antefix is "an ornament of the cymatium of a classic cornice,
# sometimes pierced for the escape of water." In reality, I'm not sure I know
# what a cymatium is. Or a cornice.

# ....................{ EXHERES                            }....................
require ant java
export_exlib_phases pkg_setup \
    src_unpack src_prepare src_compile src_test src_install

# If true, recursively delete all class files from "${WORK}" immediately after
# unpacking source archives. Such class files are bundled in source archives by
# their distributors so as to avoid the need for compiling. Make them suffer.
#
# Defaults to true.
myexparam -b clean_class_files=true
  exparam -b clean_class_files && ANT_CLEAN_CLASS_FILES=1

# If true, recursively delete all jar files from "${WORK}" immediately after
# unpacking source archives. Such jar files are bundled with source archives by
# their distributors so as to reduce dependency headaches. For us, bundled jar
# files only aggravate headaches. Cut them away.
#
# Defaults to true.
myexparam -b clean_jar_files=true
  exparam -b clean_jar_files && ANT_CLEAN_JAR_FILES=1

# If true, programmatically create a new "${WORK}/build.xml" file for this
# exheres. (Enable this for exheres providing no "build.xml", but for which the
# default "build.xml" is sufficient to build the project. Most modern Java
# projects already provide Ant, Maven, or Ivy build files; so, this should be
# used sparingly.)
#
# Defaults to true.
myexparam -b create_build_xml=false
  exparam -b create_build_xml && ANT_CREATE_BUILD_XML=1

# ....................{ CONFIGURATION                      }....................
# Absolute or relative path under ${WORK} to the "build.xml" for this exheres.
ANT_BUILD_XML="build.xml"

# Ant parameters to be passed to all command-line invocations of Ant. Example:
#     ANT_PARAMS=( -Dproject.classpath=/usr/share/zebrapig/ )
ANT_PARAMS=( )

# Ant tasks to be run against ${ANT_BUILD_XML} during the "src_prepare" phase.
# This is empty by default, implying no Ant tasks will be run for preparation.
# Example:
#     ANT_SRC_PREPARE_PARAMS=( init )
#
# This and all other Ant task arrays below are empty by default, as Ant is by
# design unable to force task names to adhere to ISO standards. In other words,
# any "build.xml" file can name its tasks anything; and they often due. Since
# there's no sensible way of predicting this, or programmatically safe way of
# extracting this from exheres-specific "build.xml" files, Ant exheres must
# manually specify these tasks.
ANT_SRC_PREPARE_PARAMS=( )

# Ant tasks to be run against ${ANT_BUILD_XML} during the "src_compile" phase.
# This is empty by default, implying no Ant tasks will be run for compilation.
# Example:
#     ANT_SRC_COMPILE_PARAMS=( compile )
ANT_SRC_COMPILE_PARAMS=( )

# Ant tasks to be run against ${ANT_BUILD_XML} during the "src_test" phase.
# This is empty by default, implying no Ant tasks will be run for testing.
# Example:
#     ANT_SRC_TEST_PARAMS=( test )
ANT_SRC_TEST_PARAMS=( )

# Ant tasks to be run against ${ANT_BUILD_XML} during the "src_install" phase.
# This is empty by default, implying no Ant tasks will be run for installation.
# Example:
#     ANT_SRC_INSTALL_PARAMS=( jar )
ANT_SRC_INSTALL_PARAMS=( )

# Array of Java JDK prefixes. If the following expression is true for at least
# one ${ANT_RESTRICT_JAVA_JDK_PREFIX} of this array, then installation fails
# prior to performing any work:
#     [[ $(eclectic java-jdk show) = "${ANT_RESTRICT_JAVA_JDK_PREFIX}"* ]]
#
# Common example for exheres failing under "gcj" or "gij":
#     ANT_RESTRICT_JAVA_JDK_PREFIXES=( gcj )
#
# As of mid 2010, all Ant exheres should test compilation under "gcj". Many will
# fail! Those that do should set this array, as above.
ANT_RESTRICT_JAVA_JDK_PREFIXES=( )

# Hamcrest does not compile under "gcj", currently.
ANT_RESTRICT_JAVA_JDK_PREFIXES=( gcj )

# Find parameters to be passed to the command-line invocation of "find" when
# cleaning jar files from ${WORK}. Specify this to prevent cleaning of wanted,
# specific jar files: e.g.,
#     ANT_CLEAN_JAR_FILES_PARAMS=( -not -wholename 'bootstrap/young_lad.jar' )
ANT_CLEAN_JAR_FILES_PARAMS=( )

# Absolute or relative path under "${WORK}" into which external jar files will
# be symlinked. Though this path is typically "lib" for most exheres, you must
# still specify this global to have symlinking performed for you. Example:
#     ANT_SRC_PREPARE_SYMLINK_DIR="lib"
ANT_SRC_PREPARE_SYMLINK_DIR=""

# Array of absolute paths to or relative names of external jar files to be
# symlinked into "${ANT_SRC_SYMLINK_DIR}". These external jar files should
# generally be buildtime dependencies of this exheres. Example mixing both
# absolute paths to and relative names of external jar files:
#     ANT_SRC_PREPARE_SYMLINK_JARS=( jarjar qdox "/usr/share/asm/asm.jar" )
#
# If filenames are not known until install time, leave this array blank and
# call "symlink_jars" within your "${PN}_src_prepare" function.
ANT_SRC_PREPARE_SYMLINK_JARS=( )

# Array of absolute paths to text files to be "deversion"-ated. Ant "build.xml"
# files often hardcode references to pre-bundled jar files with names suffixed
# by a version specifier. This is bad, as this exlib replaces all pre-bundled
# jar files with externally symlinked jar files with names NEVER EVER suffixed
# by a version specifier. To resolve the discrepancy, we could do one of two
# ugly hacks:
#
# * Sed affected "build.xml" files, removing jar filename version specifiers OR
# * Grep affected "build.xml" files for these version specifiers and, when
#   symlinking in external jar files, add the version specifier for each jar
#   filename to its symlink filename.
#
# The first is easier. And easier is better. So that's what we do. Example
# deversioning two files, "build.xml" and "common-build.xml":
#     ANT_SRC_PREPARE_DEVERSION_FILES=( "${ANT_BUILD_XML}" "common-build.xml" )
ANT_SRC_PREPARE_DEVERSION_FILES=( )

# Absolute or relative path under "${WORK}" into which javadoc HTML files will
# be generated by the "${ANT_BUILD_XML}" file for this exheres. Though this path
# is typically "javadoc" for most exheres, you must still specify this global to
# have installation of these files performed for you. Example:
#     ANT_SRC_INSTALL_JAVADOC_DIR="javadoc"
ANT_SRC_INSTALL_JAVADOC_DIR=""

# Array of absolute paths to this exheres' output jar files to be installed
# under "${ANT_SRC_INSTALL_JARS_IMAGE_DIR}". Versions are automatically removed
# from filenames on your behalf. (Yippee...!) Example:
#     ANT_SRC_PREPARE_INSTALL_JARS=( "dist/${PNV}.jar" )
#
# If filenames are not known until install time, leave this array blank and
# call "install_jars" within your "${PN}_src_install" function.
ANT_SRC_INSTALL_JARS=( )

# ....................{ CONSTANTS                          }....................
# This exlib sets these constants on your behalf. Read them; don't write them.
# 
# Scratch that -- don't even read them. If you access these constants in any
# exheres, you're doing something wrong. :)

# Absolute path to the "ant" binary.
ANT="${ANT_HOME}/bin/ant"

# Set to the currently selected Java compiler as reported by...
ANT_JAVA_JDK=$(eclectic java-jdk show)

# Set, if "gcj" is the currently selected Java compiler. This additionally
# implies "gij" is the currently selected Java interpreter.
ANT_IS_JAVA_JDK_GCJ=

# Set, if installing javadoc. (This is set for you if and only if "doc" is
# enabled for this exheres.)
ANT_IS_INSTALLING_JAVADOC=

# Absolute path to the parent of ${ANT_SRC_INSTALL_JARS_IMAGE_DIR}, below.
#
# Avoid changing this global unless you absolutely must, as that probably breaks
# things elsewhere (e.g., other exheres trying to import these jar files).
ANT_SRC_INSTALL_JARS_IMAGE_ROOT="/usr/share"

# Absolute path to which this exheres installs output jar files.
#
# Avoid changing this global unless you absolutely must, as that probably breaks
# things elsewhere (e.g., other exheres trying to import these jar files).
ANT_SRC_INSTALL_JARS_IMAGE_DIR="${ANT_SRC_INSTALL_JARS_IMAGE_ROOT}/${PN}"

# Bash pattern matching the version suffix commonly appended to jar filenames.
# This pattern matches conventional versions (e.g., "hamcrest-1.2.jar") and
# unconventional revisioned versions (e.g., "jarjar-1.0rc8.jar"). By design,
# this pattern may also be passed without change to "egrep" or "sed -r".
#
# Don't forget to append a '$' if appropriate!
ANT_JAR_VERSION_PATTERN='-[[:digit:].]+(rc[[:digit:].]+)?\.jar'

# Bash pattern matching the same from within a parameter expansion: e.g.,
#
#    Echoes "harhar.jar".
#    JAR_FILE=harhar-5.62.951.jar && \
#        echo ${JAR_FILE/${ANT_JAR_PARAMETER_VERSION_PATTERN}/.jar}
ANT_JAR_PARAMETER_VERSION_PATTERN='%-+([[:digit:].])*(rc+([[:digit:].]))\.jar'

# Sed pattern matching the version suffix commonly appended to jar filenames.
# The pattern matches conventional versions (e.g., "hamcrest-1.2.jar") and
# unconventional revisioned versions (e.g., "jarjar-1.0rc8.jar"). Note that, due
# to simplicity, the pattern may ocassionally match more than you want!
#ANT_JAR_SED_VERSION_PATTERN='-[0-9].*\.jar'

# ....................{ EXHERES GLOBALS                    }....................
# Add a buildtime dependency on "app-arch/zip" to all Ant exheres. The
# "replace_jar_manifest" function implicitly requires this binary.
DEPENDENCIES+="
    build:
        app-arch/zip
"

# ....................{ CREATE_BUILD_XML                   }....................
# This section specific to exheres using the "create_build_xml" exparam.

# If creating a new "build.xml" file, this file is guaranteed to provide the
# following exheres options and Ant tasks.
if [[ "${ANT_CREATE_BUILD_XML}" ]]; then
    MYOPTIONS+="debug doc"

    # Absolute or relative path under "${WORK}" from which sources files (e.g.,
    # .java files) will be read during compilation. You'll probably need to
    # manually move source files from wherever the archive unpacks them into
    # this directory -- unless you set ${ANT_SRC_COMPILE_SOURCE_NAMESPACE_DIR},
    # in which case this is done for you.
    ANT_SRC_COMPILE_SOURCE_DIR="src"

    # Absolute or relative path under "${WORK}" serving as the root of the Java
    # source file namespace for this exheres. Most Java projects having no
    # "build.xml" file have their namespace under "com"; thus, this will
    # probably be "com" for most exheres. For example, the JZlib project claims
    # the "com.jcraft.jzlib" namespace, and distributes a source tarball having
    # the "com/jcraft/jzlib/" directory; to appease Ant, the root of this
    # directory (e.g., "com") must be moved into a canonical directory that Ant
    # expects (e.g., "src"). So, this exheres sets:
    #     ANT_SRC_COMPILE_SOURCE_NAMESPACE_DIR="com"
    #
    # When set, this exlib automatically moves this directory under
    # ${ANT_SRC_COMPILE_SOURCE_DIR} as, again, this is what Ant expects.
    ANT_SRC_COMPILE_SOURCE_NAMESPACE_DIR=""

    # Absolute or relative path under "${WORK}" to which the output jar file
    # (NOTE: singular "jar file") will be created. Avoid changing this. If you
    # need to, you're probably better off writing your own "build.xml".
    ANT_SRC_INSTALL_JARS_DIR="dist"

    ANT_SRC_PREPARE_SYMLINK_DIR="lib"
    ANT_SRC_PREPARE_PARAMS=( )
    ANT_SRC_COMPILE_PARAMS=( compile )

    # Note: the "javadoc" task will be conditionally appended to this array,
    # later, if and only if the caller has enabled the exheres "doc" option.
    ANT_SRC_INSTALL_PARAMS=( jar )
    ANT_SRC_INSTALL_JARS=( "${ANT_SRC_INSTALL_JARS_DIR}/${PN}.jar" )
fi

# ....................{ PHASES                             }....................
antefix_pkg_setup() {
    default

    # Die if the currently selected Java compiler is exheres restricted.
    if [[ -n "${ANT_RESTRICT_JAVA_JDK_PREFIXES[@]}" ]]; then
        local ANT_RESTRICT_JAVA_JDK_PREFIX
        for   ANT_RESTRICT_JAVA_JDK_PREFIX \
            in ${ANT_RESTRICT_JAVA_JDK_PREFIXES}; do
            if [[ "${ANT_JAVA_JDK}" = "${ANT_RESTRICT_JAVA_JDK_PREFIX}"* ]]; then
                eerror "Your currently selected Java compiler is \"${ANT_JAVA_JDK}\". Unfortunately,"
                eerror "\"${PNV}\" reports that it currently fails under this compiler. Please consider"
                eerror "installing and enabling another Java compiler: e.g.,"
                eerror
                eerror "  sudo paludis -i icedtea6 && eclectic java-jdk set icedtea6-\$PV \\"
                eerror "                           && eclectic java-jre set icedtea6-\$PV"
                eerror
                eerror "where \$PV is your installed version of icedtea6 as listed by:"
                eerror
                eerror "  paludis -q icedtea6"
                die
            fi
        done
    fi

    # Warn if the currently selected Java compiler is GCJ.
    if [[ "${ANT_JAVA_JDK}" == gcj* ]]; then
        ewarn "Your currently selected Java compiler is \"gcj\". While, technically,"
        ewarn "this compiler works, it also introduces sydbox access violations by"
        ewarn "attempting to open spurious DNS requests. Until this can be"
        ewarn "corrected, please consider installing and enabling the \"icedtea6\""
        ewarn "compiler instead with:"
        ewarn
        ewarn "  sudo paludis -i icedtea6 && eclectic java-jdk set icedtea6-\$PV \\"
        ewarn "                           && eclectic java-jre set icedtea6-\$PV"
        ewarn
        ewarn "where \$PV is your installed version of icedtea6 as listed by:"
        ewarn
        ewarn "  paludis -q icedtea6"
        ewarn
        eerror "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        eerror "! Proceeding with installation, but ignoring all network sandboxing !"
        eerror "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        export ANT_IS_JAVA_JDK_GCJ=1
    fi

    # Establish whether we want javadoc installed or not via the "doc" option.
    # Do this in "pkg_setup" as that is the earliest time we may test options.
    if has doc ${MYOPTIONS} && option doc; then
        ANT_IS_INSTALLING_JAVADOC=1
    fi
}

antefix_src_unpack() {
    default

    if [[ "${ANT_CREATE_BUILD_XML}" ]]; then
        einfo "Creating ${ANT_BUILD_XML}..."
        edo pushd "${WORK}"

        [[ -f "${ANT_BUILD_XML}" ]] &&
            die "${PN} already provides a default ${ANT_BUILD_XML}!"

        create_build_xml "${ANT_BUILD_XML}"

        # Copy the source tree unpacked from the exheres tarball into the
        # canonical "${WORK}/src/" directory Ant expects.
        if [[ ! -d "${ANT_SRC_COMPILE_SOURCE_DIR}" ]]; then
            einfo "Creating source tree..."
            edo mkdir -p "${ANT_SRC_COMPILE_SOURCE_DIR}"
            if [[ -n "${ANT_SRC_COMPILE_SOURCE_NAMESPACE_DIR}" ]]; then
                edo mv "${ANT_SRC_COMPILE_SOURCE_NAMESPACE_DIR}" "${ANT_SRC_COMPILE_SOURCE_DIR}/"
            fi
        fi

        # Also ensure we generate javadoc if that option is enabled.
        if [[ -n "${ANT_IS_INSTALLING_JAVADOC}" ]]; then
            ANT_SRC_INSTALL_JAVADOC_DIR="javadoc"
            ANT_SRC_INSTALL_PARAMS+=( javadoc )
        fi

        # Pop goes the Edo jidai.
        edo popd
    fi

    # The "ant_src_prepare" function recursively destroys the contents of
    # all paths in "${ANT_BUNDLED_LIBSDIR}". Obviously, we must not destroy the
    # "${WORK}" path. However, some Java libraries (e.g., Hamcrest) come with
    # jar files pre-bundled in the "${WORK}" path. We thus homebrew this boolean
    # to recursively remove jar files rather than all files and paths, prior to
    # the "ant_src_prepare" function.
    #
    # Disable this by requiring this exlib with:
    #     require antefix [ clean_jar_files=false ]
    if [[ "${ANT_CLEAN_JAR_FILES}" ]]; then
        einfo "Removing jar files..."
        clean_jar_files
    fi

    # Disable this by requiring this exlib with:
    #     require antefix [ clean_class_files=false ]
    if [[ "${ANT_CLEAN_CLASS_FILES}" ]]; then
        einfo "Removing class files..."
        clean_class_files
    fi
}

antefix_src_prepare() {
    [[ -n "${DEFAULT_SRC_PREPARE_PATCHES}" ]] && einfo "Patching files..."
    default  # calls the original "src_prepare" function
    antefix_src_preamble

    # Deversion files after patching files above but before invoking Ant below.
    if [[ -n "${ANT_SRC_PREPARE_DEVERSION_FILES[@]}" ]]; then
        einfo "Removing jar filename version specifiers..."
        antefix_deversion_files ${ANT_SRC_PREPARE_DEVERSION_FILES[@]}
    fi

    # Never invoke Ant unless you have a task with which to invoke it, since
    # "build.xml" files often supply a default task performing all relevant
    # tasks when passed no explicit task. (This is rarely what we want.)
    if [[ -n "${ANT_SRC_PREPARE_PARAMS[@]}" ]]; then
        einfo "Preparing source files..."
        ANT_SRC_PREPARE_PARAMS=( ${ANT_PARAMS[@]} ${ANT_SRC_PREPARE_PARAMS[@]} )
        ant_src_prepare
    fi

    if [[ -n "${ANT_SRC_PREPARE_SYMLINK_JARS[@]}" ]]; then
        einfo "Linking external jar files..."
        set_symlink_jar_dir "${ANT_SRC_PREPARE_SYMLINK_DIR}"
        symlink_jars         ${ANT_SRC_PREPARE_SYMLINK_JARS[@]}
    fi
}

antefix_src_compile() {
    antefix_src_preamble

    if [[ -n "${ANT_SRC_COMPILE_PARAMS[@]}" ]]; then
        einfo "Compiling source files..."
        ANT_SRC_COMPILE_PARAMS=( ${ANT_PARAMS[@]} ${ANT_SRC_COMPILE_PARAMS[@]} )
        ant_src_compile
    fi
}

antefix_src_test() {
    antefix_src_preamble

    if [[ -n "${ANT_SRC_TEST_PARAMS[@]}" ]]; then
        einfo "Testing compiled files..."
        ANT_SRC_TEST_PARAMS=( ${ANT_PARAMS[@]} ${ANT_SRC_TEST_PARAMS[@]} )
        ant_src_test
    fi
}

antefix_src_install() {
    antefix_src_preamble

    einfo "Installing documents..."
    emagicdocs

    # Also ensure we generate javadoc if the user enabled the "doc" option and
    # this exheres specified a directory having generated javadoc. (That's a few
    # ifs.)
    if [[ -n "${ANT_IS_INSTALLING_JAVADOC}" ]] &&
       [[ -n "${ANT_SRC_INSTALL_JAVADOC_DIR}" ]]; then
        einfo "Installing javadoc..."
        docinto html/javadoc
        dodoc "${ANT_SRC_INSTALL_JAVADOC_DIR}"/*
    fi

    if [[ -n "${ANT_SRC_INSTALL_PARAMS[@]}" ]]; then
        einfo "Collecting jar files..."
        ANT_SRC_INSTALL_PARAMS=( ${ANT_PARAMS[@]} ${ANT_SRC_INSTALL_PARAMS[@]} )
        ant_src_install
    fi

    if [[ -n "${ANT_SRC_INSTALL_JARS[@]}" ]]; then
        einfo "Installing jar files... ${ANT_SRC_INSTALL_JARS[@]}"
        install_jars ${ANT_SRC_INSTALL_JARS[@]}
    fi
}

antefix_src_preamble() {
    if [[ -n "${ANT_IS_JAVA_JDK_GCJ}" ]]; then
        ewarn "Disabling network sandboxing..."
        sydboxcmd 'sandunbox/net'
    fi
}

# ....................{ CLEANERS                           }....................
# void clean_jar_files(void)
#
# Recursively remove all jar files under ${WORK}. (Fairly destructive!)
clean_jar_files() {
    # Do not use "edo rm -f "${WORK}"/**/*.jar" as that tends to glob more
    # files than can be reasonably handled by the shell.
    edo find "${WORK}" -type f -iname '*.jar' \
        ${ANT_CLEAN_JAR_FILES_PARAMS[@]} -delete
}

# void clean_class_files(void)
#
# Recursively remove all class files under ${WORK}. (Danger, Exherbon.)
clean_class_files() {
    edo find "${WORK}" -type f -iname '*.class' -delete
}

# ....................{ DEVERSIONERS                       }....................
# void antefix_deversion_files(char *filename1, char *filename2, ...)
#
# Patch the passed absolute or relative filenames of jar file version suffixes.
# These files are typically "build.xml" files, so as to generalize their build
# process to non-versioned jar files installed on the local machine.
antefix_deversion_files() {
    local EPN
    local ANT_DEVERSION_FILE
    for   ANT_DEVERSION_FILE in ${*}; do
        # Implicitly remove filename version specifiers matching:
        # "-${DSTAMP}.jar", "-${TSTAMP}.jar", or "-${TODAY}.jar". These
        # are Ant properties generated by the "tstamp" task and, when
        # used in jar filenames, mostly produce badly named jar files.
        #
        # This should be safe... should.
        edo sed -r \
            -e 's:-\$\{(DSTAMP|TSTAMP|TODAY)\}\.jar:.jar:' \
            -i "${ANT_DEVERSION_FILE}"

        # Explicitly remove filename version specifiers only for externally
        # symlinked jar files, where the 'E' in "EPN" stands for external.
        #
        # Do not remove version specifiers from other jar filenames as those
        # filenames may not actually exist. As we can't be sure, we don't.
        if [[ -n "${ANT_SRC_PREPARE_SYMLINK_JARS[@]}" ]]; then
            for EPN in ${ANT_SRC_PREPARE_SYMLINK_JARS[@]}; do
                if [[ "${EPN:0:1}" != / ]]; then  # ignore absolute paths
                    edo sed -r \
                        -e "s:${EPN}${ANT_JAR_VERSION_PATTERN}:${EPN}.jar:" \
                        -i "${ANT_DEVERSION_FILE}"
                fi
            done
        fi
    done
}

# ....................{ SYMLINKERS                         }....................
# The following convenience functions symbolically link external Java libraries
# into the current exhere's work directory prior to compilation of that exheres.

# void set_symlink_jar_dir(char *pathname)
#
# Set the path of the directory into which external jar files should be
# symbolically linked for this exheres. The "build.xml" file for this exheres
# presumably requires these external jar files to be present in this directory
# prior to operation. The "prepare_jar*" family of functions, below, operate on
# this directory until the next invocation of this function.
#
# If absolute, no path processing is performed upon the filename aside from
# ensuring that this path resides under "${WORK}/"; if relative, the absolute
# path "${WORK}/" is prepended to this path.
#
# By convention, this is usually just "lib". Most Java libraries are different,
# of course.
set_symlink_jar_dir() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "one and only one argument needed"

    ANT_SRC_PREPARE_SYMLINK_DIR="${1}"

    # If we were passed an absolute path, test it.
    if [[ ${ANT_SRC_PREPARE_SYMLINK_DIR:0:1} == / ]]; then
        [[ "${ANT_SRC_PREPARE_SYMLINK_DIR}" == "${WORK}"* ]] ||
            die_unless_nonfatal "${ANT_SRC_PREPARE_SYMLINK_DIR} not under ${WORK}"
    # If we were passed a relative path, canonicalize it.
    else
        ANT_SRC_PREPARE_SYMLINK_DIR="${WORK}/${ANT_SRC_PREPARE_SYMLINK_DIR}"
    fi

    # If the path exists, remove all jar files the archive extracted into it.
    # This provides a convenient alternative to the rather cumbersome
    # "${ANT_BUNDLED_LIBSDIR}" array.
    if [[ -d "${ANT_SRC_PREPARE_SYMLINK_DIR}" ]]; then
        edo rm -f "${ANT_SRC_PREPARE_SYMLINK_DIR}"/*.jar
    # Otherwise, create the path. It should already be, in general.
    else
        edo install -d "${ANT_SRC_PREPARE_SYMLINK_DIR}"
    fi

    # Notify the world!
    export ANT_SRC_PREPARE_SYMLINK_DIR
}

# void symlink_jars(char *filename1, char *filename2, ...)
#
# Symbolically link jar filenames to relative filenames having the same basename
# under the above directory. Input jar filenames may be either absolute or
# relative. If absolute, no path processing is performed upon the filename; if
# relative, the absolute path "/usr/share/$(basename $filename)/" is prepended
# to that filename. Input jar filenames may or may not have the ".jar" suffix
# appended, as well. Filenames that do not will simply have the ".jar" suffix
# appended. Thus, "jarjar" becomes "/usr/share/jarjar/jarjar.jar". For each
# such filename, this performs the equivalent of:
#
#   ln -s "$filename" "$symlink_jar_dir"/
#
# But that's not all. If relative and not found under
# "/usr/share/$(basename $filename)/", we then look under
# "/usr/share/$(basename ${filename%%-*})/". This is the first part of the
# filename up to but not including the first hyphen. Thus, this:
#   
#   symlink_jars hamcrest-core
#
# tries the following paths in order:
#
# * "/usr/share/hamcrest-core/hamcrest-core.jar", which will not be found. 
# * "/usr/share/hamcrest/hamcrest-core.jar", which will be found. 
#
# In other words, this function has enough cleverness to usually suss out the
# absolute path to whatever you pass it. When it doesn't, simply pass the
# absolute path!
symlink_jars() {
    illegal_in_global_scope
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"
    [[ -d "${ANT_SRC_PREPARE_SYMLINK_DIR}" ]] ||
        die_unless_nonfatal "${ANT_SRC_PREPARE_SYMLINK_DIR} not found or not set"

    local JAR_FILE
    for   JAR_FILE in ${*}; do
        # Canonicalize relative jar filenames to absolute jar filenames.
        if [[ ${JAR_FILE:0:1} != / ]]; then
            JAR_FILE=$(which_installed_jar_file "${JAR_FILE}")
        fi

        edo ln -s "${JAR_FILE}" "${ANT_SRC_PREPARE_SYMLINK_DIR}"/
    done
}

# ....................{ INSTALLERS                         }....................
# The following convenience functions install all Java libraries produced by
# this exheres into local directories appropriate for this exheres.

# void install_jars(char *filename1, char *filename2, ...)
#
# Copy absolute filenames to relative filenames having the same basename sans
# version under the above directory. By "sans version", we mean basename minus
# "-${PV}". Jar filenames should be versionless so as to permit their usage
# elsewhere without concern for the specific versions they represent. This
# resembles:
#
#   cp "$filename1" "$filename2" ... "${IMAGE}/${ANT_SRC_INSTALL_JARS_IMAGE_DIR}"
install_jars() {
    illegal_in_global_scope
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"
    [[ "${ANT_SRC_INSTALL_JARS_IMAGE_DIR}" =~ ^/(usr|opt)/ ]] ||
        die_unless_nonfatal "${ANT_SRC_INSTALL_JARS_IMAGE_DIR} not under /usr or /opt"

    insinto "${ANT_SRC_INSTALL_JARS_IMAGE_DIR}"

    local JAR_FILE
    for   JAR_FILE in ${*}; do
        # Strip versions from filenames: e.g., convert "zebrapig-0.42.jar" to
        # "zebrapig.jar". The pattern substitution requires the bash "extglob"
        # shell option be enabled, which it is under exheres-0.
        #
        # See "man bash" for details.
        newins ${JAR_FILE} \
            $(basename "${JAR_FILE/${ANT_JAR_PARAMETER_VERSION_PATTERN}/.jar}")
    done
}

# void install_jar_as(char *filename1, char *filename2)
#
# Copy absolute "$filename1" to relative "$filename2" under the above directory.
# This is functionally equivalent to:
#
#   cp "$filename1" "${IMAGE}/$install_jar_dir/$filename2"
install_jar_as() {
    illegal_in_global_scope
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "exactly two arguments needed"
    [[ "${ANT_SRC_INSTALL_JARS_IMAGE_DIR}" =~ ^/(usr|opt)/ ]] ||
        die_unless_nonfatal "${ANT_SRC_INSTALL_JARS_IMAGE_DIR} not under /usr or /opt"

    local JAR_FILE_IN="${1}"
    local JAR_FILE_OUT="${2}"

    # Escape the first character of the version pattern to prevent grep from
    # interpreting the character as a dash option.
    if [[ "${JAR_FILE_OUT}" =~ "${ANT_JAR_VERSION_PATTERN}$" ]]; then
        ewarn "${JAR_FILE_OUT} contains a version specifier"
    fi

    insinto "${ANT_SRC_INSTALL_JARS_IMAGE_DIR}"
    newins "${JAR_FILE_IN}" "${JAR_FILE_OUT}"
}

# char *which_installed_jar_dir(char *exheres_name)
#
# Given an exheres name, returns the absolute path to the installed directory
# having jar files for that exheres: e.g.,
#
#     # Echoes "/usr/share/turkish_dream".
#     echo $(which_installed_jar_dir "turkish_dream")
#
# This function ensures this path exists, and dies if it does not.
which_installed_jar_dir() {
    local JAR_DIR=$(which_installed_jar_dir_nonfatal "${1}")
    [[ -d "${JAR_DIR}" ]] ||
        die_unless_nonfatal "jar directory ${JAR_DIR} not found"
    echo "${JAR_DIR}"
}

# char *which_installed_jar_dir_nonfatal(char *exheres_name)
#
# Behaves similarly to "which_installed_jar_dir" but does not ensure this path exist.
which_installed_jar_dir_nonfatal() {
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "exactly one argument needed"
    [[ -n "${1}"  ]] || die_unless_nonfatal "non-null argument needed"
    echo "${ANT_SRC_INSTALL_JARS_IMAGE_ROOT}/${1}"
}

# char *which_installed_jar_file(char *jar_file)
# --OR--
# char *which_installed_jar_file(char *exheres_name, char *jar_file)
#
# Given a jar file and optional exheres name, returns the absolute path to the
# installed file for the jar file under the exheres name: e.g.,
#
#     # Echoes "/usr/share/hamcrest/hamcrest-library.jar".
#     echo $(which_installed_jar_file "hamcrest-library")
#     # Echoes "/usr/share/raki-saki/raki-saki-core.jar".
#     echo $(which_installed_jar_file "dist/lib/raki-saki-core.5.22.jar")
#     # Echoes "/usr/share/raki-saki/org.turkish.dream.jar".
#     echo $(which_installed_jar_file "raki-saki" "bin/org.turkish.dream-0.1.3.jar")
#
# This automatically strips version strings from passed jar filenames as well as
# establishing the expected parent directory. As above, this function ensures
# the file exists, and dies if it does not.
which_installed_jar_file() {
    [[ ${#} -eq 1 ]] ||
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "one or two arguments needed"
    [[ -n "${1}"  ]] || die_unless_nonfatal "non-null argument needed"

    local JAR_FILE EXHERES_NAME
    if [[ ${#} -eq 1 ]]
    then JAR_FILE="${1}"; EXHERES_NAME=
    else JAR_FILE="${2}"; EXHERES_NAME="${1}"
    fi
    local JAR_BASENAME="${JAR_FILE/##*/}"        # filename sans path
    local JAR_ROOTNAME="${JAR_BASENAME/%.jar/}"  # filename sans path and type
    if [[ -z "${EXHERES_NAME}" ]]
    then EXHERES_NAME="${JAR_ROOTNAME}"
    fi

    # If we were passed a relative path, canonicalize it. Presume all
    # external Java libraries live in their customary directories.
    #
    # Do not search "${IMAGE}"/ as well, as absolute paths into that root will
    # be rendered meaningless after installation.
    JAR_FILE="${ANT_SRC_INSTALL_JARS_IMAGE_ROOT}/${EXHERES_NAME}/${JAR_ROOTNAME}.jar"
    if [[ ! -f "${JAR_FILE}" ]]; then
        JAR_FILE="${ANT_SRC_INSTALL_JARS_IMAGE_ROOT}/${EXHERES_NAME%%-*}/${JAR_ROOTNAME}.jar"
        [[  -f "${JAR_FILE}" ]] ||
            die_unless_nonfatal "${JAR_ROOTNAME}.jar not found"
    fi

    echo "${JAR_FILE}"
}

# char *which_installed_jar_file_nonfatal(char *jar_file)
# --OR--
# char *which_installed_jar_file_nonfatal(char *exheres_name, char *jar_file)
#
# Behaves similarly to "which_installed_jar_file" but does not ensure this file
# exists. (This is somewhat less intelligent than that function, and should thus
# be avoided in favor of calling "which_installed_jar_file" itself.)
which_installed_jar_file_nonfatal() {
    [[ ${#} -eq 1 ]] ||
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "one or two arguments needed"
    [[ -n "${1}"  ]] || die_unless_nonfatal "non-null argument needed"

    local JAR_FILE EXHERES_NAME
    if [[ ${#} -eq 1 ]]
    then JAR_FILE="${1}"; EXHERES_NAME=
    else JAR_FILE="${2}"; EXHERES_NAME="${1}"
    fi
    local JAR_BASENAME="${JAR_FILE/##*/}"        # filename sans path
    local JAR_ROOTNAME="${JAR_BASENAME/%.jar/}"  # filename sans path and type
    if [[ -z "${EXHERES_NAME}" ]]
    then EXHERES_NAME="${JAR_ROOTNAME}"
    fi

    echo "${ANT_SRC_INSTALL_JARS_IMAGE_ROOT}/${EXHERES_NAME}/${JAR_ROOTNAME}.jar"
}

# ....................{ BUILD.XML                          }....................
# void create_build_xml(char *filename)
#
# Create a new "build.xml" file at the passed absolute or relative path
# appropriate for building this exheres. This is only appropriate for those
# exheres not already providing a "build.xml" file. By convention, this file
# defines the following top-level Ant tasks:
#
# * "compile", compiling class files for this exheres from "src/" to "build/".
# * "jar", jaring this exheres into "dist/".
# * "javadoc", generating HTML files for this exheres in "javadoc/".
#
# These tasks accept the following Ant properties at the command-line:
#
# * "src", an absolute or relative path to the root of the source directory.
#   Defaults to "${WORK}/src/". (You will probably have to either manually move
#   the source directory for this exheres to this default or redefine this
#   property. Either are fine.)
# * "lib", an absolute or relative path to the root of the input jar file
#   directory (i.e., the directory having symlinks to external dependencies).
#   Defaults to "${WORK}/lib/". (This exlib ensures that these dependencies will
#   be symlinked into this directory, when specified via the
#   ${ANT_SRC_PREPARE_SYMLINK_DIR} global.)
# * "build", an absolute or relative path to the root of the classes directory.
#   Defaults to "${WORK}/build/".
# * "dist", an absolute or relative path to the root of the output jar file
#   directory. Defaults to "${WORK}/build/".
# * "javadoc", an absolute or relative path to the root of the output javadoc
#   directory. Defaults to "${WORK}/javadoc/".
# * "debug", a "true" or "false" boolean that, if true, embeds debugging
#   metadata in compiled class files. Defaults to "false".
#
# Thus, exheres need to ensure source files appear in the directory
# corresponding to the "src" property, which defaults to "${WORK}/src/". But
# that's it. This exlib takes care of everything else for you. See
# implementation for details.
create_build_xml() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "exactly one argument needed"

    local BUILD_XML_SRC_DIR="${ANT_SRC_COMPILE_SOURCE_DIR:-src}"
    local BUILD_XML_LIB_DIR="${ANT_SRC_PREPARE_SYMLINK_DIR:-lib}"
    local BUILD_XML_DIST_DIR="${ANT_SRC_INSTALL_JARS_DIR:-dist}"
    local BUILD_XML_JAR_FILE="${ANT_SRC_INSTALL_JARS[1]:-${BUILD_XML_DIST_DIR}/${PN}.jar}"
    local BUILD_XML_JAVADOC_DIR="${ANT_SRC_INSTALL_JAVADOC_DIR:-javadoc}"

    local BUILD_XML_DEBUG="false"
    if has debug ${MYOPTIONS}; then
        BUILD_XML_DEBUG=$(option debug && echo true || echo false)
    fi

    cat <<EOF > "${1}" 
<?xml version="1.0" encoding="utf-8"?>
<project name="${PN}" default="jar" basedir=".">
    <property name="src"     location="${BUILD_XML_SRC_DIR}"/>
    <property name="lib"     location="${BUILD_XML_LIB_DIR}"/>
    <property name="build"   location="build"/>
    <property name="dist"    location="${BUILD_XML_DIST_DIR}"/>
    <property name="javadoc" location="${BUILD_XML_JAVADOC_DIR}"/>
    <property name="jar"     value="${BUILD_XML_JAR_FILE}"/>
    <property name="debug"   value="${BUILD_XML_DEBUG}"/>

    <path id="lib.classpath">
        <fileset dir="\${lib}">
            <include name="**/*.jar"/>
        </fileset>
    </path>

    <target name="init">
        <tstamp/>
        <mkdir dir="\${lib}"/>
        <mkdir dir="\${build}"/>
        <mkdir dir="\${dist}"/>
        <mkdir dir="\${javadoc}"/>
    </target>

    <target name="compile" depends="init">
        <javac srcdir="\${src}" destdir="\${build}" debug="\${debug}"
               classpathref="lib.classpath"/>
    </target>

    <target name="jar" depends="compile">
        <jar jarfile="\${jar}" basedir="\${build}"/>
    </target>

    <target name="javadoc" depends="init">
        <javadoc sourcepath="\${src}" destdir="\${javadoc}"
                 classpathref="lib.classpath">
            <packageset dir="\${src}"/>
        </javadoc>
    </target>
</project>
EOF
}

# ....................{ MANIFEST.MF                        }....................
# void replace_jar_manifest(char *jar_filename, char *manifest_filename)
#
# Replace "META-INF/MANIFEST.MF" in the passed jar filename with the passed
# manifest filename. Also, substitute placeholder variables with their current
# Bash values as performed by the "patch_jar_manifest" function.
#
# Exheres usually call this function from "${PN}_src_install", often overriding
# exheres globals with jar file-specific locals: e.g.,
#
#     local PV=0.8.1   # ...hides the global ${PV}
#     replace_jar_manifest "dist/${PN}.jar" "${FILES}/${PN}-MANIFEST.MF"
replace_jar_manifest() {
    illegal_in_global_scope
    [[ ${#} -eq 2        ]] || die_unless_nonfatal "exactly two arguments needed"
    [[ -x "/usr/bin/zip" ]] || die_unless_nonfatal "zip not installed"

    local      JAR_FILE="${1}"
    local MANIFEST_FILE="${2}"

    # Copy the source to target manifest file, and patch placeholders.
    edo mkdir -p              "${TEMP}/META-INF"
    edo cp "${MANIFEST_FILE}" "${TEMP}/META-INF/MANIFEST.MF"
    patch_jar_manifest        "${TEMP}/META-INF/MANIFEST.MF"

    # Move the jar file to the temporary path having the target manifest,
    # temporarily renaming it for convenience.
    edo mv "${JAR_FILE}" "${TEMP}/jar.jar"

    # The activated JDK necessarily installs a "jar" binary. This binary permits
    # updating, but not replacement, of existing jar file manifest files. That's
    # not what we want; so, unfortunately, we depend on the "zip" binary. This
    # binary is not guaranteed to be installed; when installed, it requires we
    # we change directories.
    edo pushd "${TEMP}"
    edo zip -q "jar.jar" "META-INF/MANIFEST.MF"

    # Get us home, Commander Gaeta.
    edo popd

    # Move the jar file to its original path.
    edo mv "${TEMP}/jar.jar" "${JAR_FILE}"
}

# void patch_jar_manifest(char *manifest_filename)
#
# Patch contents of the passed manifest filename or "META-INF/MANIFEST.MF" from
# the current directory, if no manifest filename is passed. In particular,
# substitute placeholder variables in the manifest with their current values.
# Recognized placeholders are:
#
# * __PV__, which will be substituted with ${PV}.
# * %bundleName, which will be substituted with ${BUNDLE_NAME}
# * %providerName, which will be substituted with ${PROVIDER_NAME}
#
# Placeholder variables prefixed by '%' are specific to the Java OSGI standard.
# Placeholder variables enclosed by '__' are specific to this function, and
# chosen so as to avoid conflicting with existing manifest file text.
#
# Exheres usually call this function from "${PN}_src_prepare", often overriding
# exheres globals with jar file-specific locals: e.g.,
#
#     local PV=3.0.2                   # ...hides the global ${PV}
#     local BUNDLE_NAME="SAT4J Core"   # ...hides the global ${BUNDLE_NAME}
#     patch_jar_manifest "${WORK}/build/META-INF/MANIFEST.MF"
#
# !!!!!IMPORTANT!!!!! strings substituted into placeholder variables must not
# contain backtick characters '`', as the sed expressions performing these
# substitutions use that character to delimit themselves. Since this would be a
# strange character for a string to contain, this is generally "safe."
patch_jar_manifest() {
    illegal_in_global_scope
    [[ ${#} -le 1 ]] || die_unless_nonfatal "zero or one arguments needed"

    local MANIFEST_FILE="${1:-META-INF/MANIFEST.MF}"
    local PROVIDER_NAME="${PROVIDER_NAME:-Exherbo!}"

    # Substitute placeholder variables, with undefined variables simply
    # expanding to the empty string.
    edo sed -i "${MANIFEST_FILE}" \
        -e "s\`__PV__\`${PV}\`" \
        -e "s\`%bundleName\`${BUNDLE_NAME}\`" \
        -e "s\`%providerName\`${PROVIDER_NAME}\`"
}

# ....................{ EANT                               }....................
# void eant(char *build_xml_filename, char *param1, char *param2, ...)
#
# Call "ant" with the passed absolute or relative path to a "build.xml" file and
# zero or more command-line parameters to be passed to this "build.xml" file.
# These parameters must be either: {a} Ant properties of the form "-Dkey=value"
# (e.g., "-Djavacc.home=lib/javacc.jar") or {b} Ant tasks of the form "task"
# (e.g., "compile").
#
# This function supplants the earlier "_ant_run" function and, unlike that
# function, may be explicitly called by exheres operating on multiple
# "build.xml" files. (Exheres not operating on multiple "build.xml" files should
# avoid calling this function explicitly.)
eant() {
    illegal_in_global_scope
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"

    local ANT_BUILD_XML="${1}"
    shift

    # Always enable the "noget" property when invoking Ant. This instructs Ant
    # to ignore any "get" tasks defined by this "build.xml" file; such tasks,
    # if defined, attempt to remotely download external jar files.
    edo "${ANT}" -f "${ANT_BUILD_XML}" -Dnoget=true "${@}"
}
